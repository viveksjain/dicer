package com.databricks.dicer.assigner.algorithm

import java.time.Instant

import scala.collection.mutable
import scala.concurrent.duration._

import com.databricks.api.proto.dicer.external.LoadBalancingMetricConfigP.ImbalanceToleranceHintP
import com.databricks.caching.util.UnixTimeVersion
import com.databricks.caching.util.TestUtils.assertThrow
import com.databricks.dicer.assigner.algorithm.Algorithm.computeAdjustedLoadMap
import com.databricks.dicer.assigner.AssignmentStats.AssignmentLoadStats
import com.databricks.dicer.assigner.config.{ChurnConfig, InternalTargetConfig}
import com.databricks.dicer.assigner.config.InternalTargetConfig.{
  KeyReplicationConfig,
  LoadBalancingConfig,
  LoadBalancingMetricConfig
}
import com.databricks.dicer.assigner.MigrationTestAssignment
import com.databricks.dicer.assigner.MigrationTestAssignment._
import com.databricks.dicer.assigner.MigrationTestAssignment.TestSliceReplica._
import com.databricks.dicer.common.{
  Assignment,
  AssignmentConsistencyMode,
  Generation,
  ProposedAssignment,
  ProposedSliceAssignment,
  SliceAssignment,
  SliceMapHelper,
  Squid,
  SubsliceAnnotation
}
import com.databricks.dicer.common.SliceKeyHelper.RichSliceKey
import com.databricks.dicer.common.TestSliceUtils._
import com.databricks.dicer.external.{Slice, SliceKey, Target}
import com.databricks.dicer.friend.{MutableSliceMap, SliceMap}

/** Tests which are not parameterized over different key replication configs. */
class NonParameterizedAlgorithmSuite extends AlgorithmSuiteBase {

  /**
   * The test harness for a migration test case.
   *
   * @param description A description string for debug that shows up when any test assertion fails.
   * @param predecessor A [[MigrationTestAssignment]] representation of the predecessor assignment
   *                    that the Algorithm will run based on.
   * @param expectedOutput A [[MigrationTestAssignment]] representation of the expected assignment
   *                       generated by Algorithm. Will be checked against the generated assignment
   *                       using
   *                      [[MigrationTestAssignment.assertHasSameInterestingSlicesAndTotalLoadsAs]].
   * @param churnConfig The ChurnConfig that Algorithm will run with.
   * @param keyReplicationConfig The KeyReplicationConfig that Algorithm will run with.
   * @param assignmentAge The age of the predecessor assignment when the Algorithm is running. Used
   *                      to control or test churn-related behaviors.
   * @param resourcesOverrideOpt Optional override of the available resources used when generating
   *                             the new assignment. When empty, the assigned resources in
   *                             `predecessor` will be used.
   * @param maxLoadHint The max load hint that Algorithm will run with.
   */
  private case class MigrationTestCase(
      description: String,
      predecessor: MigrationTestAssignment,
      expectedOutput: MigrationTestAssignment,
      // Disable churn penalties by default so that it's easier to reason about the effective load.
      churnConfig: ChurnConfig = ChurnConfig.ZERO_PENALTY,
      keyReplicationConfig: KeyReplicationConfig = KeyReplicationConfig.DEFAULT_SINGLE_REPLICA,
      // Default assignment age chosen such that there's no lingering churn penalty for previously
      // assigned Slices for tests that don't care about churn.
      assignmentAge: FiniteDuration = 24.hours,
      resourcesOverrideOpt: Option[Resources] = None,
      maxLoadHint: Double = 100.0) {

    /**
     * Runs the MigrationTestCase by running the Algorithm with the given `predecessor` and
     * configurations, and verifies that the resulting assignment is compatible with
     * `expectedOutput`.
     *
     * Before running the Algorithm, it also performs a mandatory sanity check that the policy phase
     * of the Algorithm won't change the number of replicas of each slice. Test authors are
     * responsible to set proper predecessor assignment and configurations to make sure the sanity
     * check passes.
     */
    def run(): Unit = {
      val targetConfig = createConfigForLoadBalancing(this.churnConfig, this.maxLoadHint)
        .copy(keyReplicationConfig = keyReplicationConfig)
      val resources: Resources =
        this.resourcesOverrideOpt
          .getOrElse(Resources.create(this.predecessor.assignment.assignedResources))
      val predecessorAssignment: Assignment = this.predecessor.assignment
      val loadMap: LoadMap = this.predecessor.loadMap

      assertNoReplicaAdjust(targetConfig, resources, predecessorAssignment, loadMap)

      // Set the generate instant to the generation time of the predecessor plusing the assignment
      // age.
      val generateInstantEpochMilli: Long =
        this.predecessor.assignment.generation.number.value + this.assignmentAge.toMillis
      val proposal: ProposedAssignment = ProposedAssignment(
        predecessorOpt = Some(this.predecessor.assignment),
        Algorithm.generateAssignment(
          Instant.ofEpochMilli(generateInstantEpochMilli),
          target,
          targetConfig,
          resources,
          predecessorAssignment.sliceMap,
          loadMap
        )
      )
      val assignment: Assignment = proposal.commit(
        isFrozen = false,
        AssignmentConsistencyMode.Affinity,
        // The commit generation of the new assignment is not interesting. Just make it slightly
        // larger than `generateInstantEpochMilli` to make sure the requirement of
        // ProposedAssignment.commit() is satisfied.
        generation = predecessor.assignment.generation
          .copy(number = UnixTimeVersion(generateInstantEpochMilli + 1))
      )
      this.expectedOutput.assertHasSameInterestingSlicesAndTotalLoadsAs(
        assignment,
        description + s", predecessor assignment: ${predecessor.assignment}"
      )
    }

    /**
     * Asserts that based on the given `targetConfig`, a set of available `resources`, a
     * `predecessorAssignment` and a `loadMap`, when running the Algorithm, the policy phase of
     * the Algorithm won't change the number of replicas of each slice in the predecessor
     * assignment.
     */
    private def assertNoReplicaAdjust(
        targetConfig: InternalTargetConfig,
        resources: Resources,
        predecessorAssignment: Assignment,
        loadMap: LoadMap): Unit = {
      // Calculate the reservation adjusted load map.
      val totalRawLoad: Double = loadMap.getLoad(Slice.FULL)
      val totalReservedLoad: Double = targetConfig.loadBalancingConfig.primaryRateMetric
        .getUniformReservedLoad(
          availableResourceCount = predecessorAssignment.assignedResources.size
        )
      val totalReservationAdjustedLoad: Double = totalRawLoad + totalReservedLoad
      val reservationAdjustedLoadMap: LoadMap =
        computeAdjustedLoadMap(
          targetConfig.loadBalancingConfig,
          resources.availableResources.size,
          this.predecessor.loadMap
        )

      val desiredLoadRange: Algorithm.DesiredLoadRange = Algorithm.calculateDesiredLoadRange(
        targetConfig.loadBalancingConfig,
        resources.availableResources.size,
        totalReservationAdjustedLoad
      )

      // Check the number of replicas and load of each slice to make sure no (de)replication will
      // be performed.
      for (sliceAssignment: SliceAssignment <- predecessorAssignment.sliceAssignments) {
        val adjustedPerReplicaLoad: Double =
          reservationAdjustedLoadMap.getLoad(sliceAssignment.slice) / sliceAssignment.resources.size
        val numReplicas: Int = sliceAssignment.resources.size
        assert(
          numReplicas <= keyReplicationConfig.maxReplicas,
          s"SliceAssigment $sliceAssignment will be de-replicated from $numReplicas to " +
          s"the configured maxReplicas ${keyReplicationConfig.maxReplicas}"
        )
        assert(
          numReplicas >= keyReplicationConfig.minReplicas,
          s"SliceAssigment $sliceAssignment will be replicated from $numReplicas to " +
          s"the configured minReplicas ${keyReplicationConfig.maxReplicas}"
        )
      }
    }
  }

  /**
   * REQUIRES: Any key of `points` must be a valid probability, i.e. within [0.0, 1.0].
   * REQUIRES: The values of `points` must be non-decreasing with respect to the keys.
   *
   * A set of discrete data points from an Inverse Cumulative Distribution Function (ICDF) of some
   * distribution or data set. An entry (p, v) in `points` indicates that a fraction p of samples
   * had a value <= v (or in the case of describing a random variable X, X <= v with probability p).
   */
  /**
   * The test harness encapsulating the test data and expected results for an asymmetric key
   * replication test case. The test case will generate a new assignment based on the setup
   * parameters, and verify the resulting assignment by [[assertDesirableAssignmentProperties]] and
   * also by the verification parameters supplied below.
   *
   * Setup parameters:
   *
   * @param description            A string describing the test case. Will be shown in error
   *                               messages.
   * @param predecessor            A proposal of the predecessor/base assignment that the Algorithm
   *                               will run based from.
   * @param keyReplicationConfig   The [[KeyReplicationConfig]] the Algorithm will run with, and
   *                               that the result will be verified against.
   * @param imbalanceToleranceHint The [[ImbalanceToleranceHintP]] the Algorithm will run with, and
   *                               that the result will be verified against.
   * @param maxLoadHint            The maximum load hint the Algorithm will run with, and that the
   *                               result will be verified against.
   * @param churnConfig            The churn config used when generating the assignment.
   * @param loadMapOverrideOpt     Optional override load map. When defined, the Algorithm will be
   *                               running with this load map; otherwise, the Algorithm will use the
   *                               load specified in [[predecessor]].
   * @param sliceReplicaAgeOverride
   *        Map that specifies the overridden continuous assignment age for slice replicas. The
   *        slice replicas in [[predecessor]], if fully covered/contained by an entry in this map,
   *        will be overridden to have the specified continuous assignment age. Slice replicas in
   *        [[predecessor]] not covered by any entry in this map will have 0 continuous assignment
   *        age (continuous generation time = now). Slices in this map may duplicate/overlap with
   *        each other, and the slices that appear latter in the map will override the age values of
   *        previous slices overlapped with it. For example,
   *
   *        `Map((Slice.FULL, "pod-0") -> 1.minute, (42 -- 43, "pod-0") -> 2.minutes)`
   *        predecessor: ["" -- 42) -> {pod-0}
   *                     [42 -- 43) -> {pod-0, pod-1}
   *                     [43 -- ∞)  -> {pod-0}
   *        Then the final continuous assignment time will be overridden to:
   *                     ["" -- 42) -> {pod-0 @ (now - 1.minute) }
   *                     [42 -- 43) -> {pod-0 @ (now - 2.minutes), pod-1 @ now }
   *                     [43 -- ∞)  -> {pod-0 @ now}
   *
   * Verification parameters:
   *
   * @param expectedReplicas              A map containing the expected replicas or number of
   *                                      replicas for slices. Slices presented in this map should
   *                                      show up in the resulting assignment with exactly matched
   *                                      boundaries, and contains exactly matched assigned
   *                                      resources or number of replicas as specified by this map.
   *                                      The slices that don't show up in this map will be verified
   *                                      to have the minimum possible number of replicas
   *                                      (configured minReplicas or number of available resources,
   *                                      whichever smaller).
   *                                      TODO(<internal bug>): Make the value of expectedReplicas a
   *                                                       trait instead of an Either for
   *                                                       readability.
   * @param expectedResourceLoads         Specifying the expected total (real) load for resources.
   *                                      Load of resources that don't show in this map will not be
   *                                      specially verified (but will still be verified by
   *                                      [[assertDesirableAssignmentProperties]].
   * @param imbalanceToleranceOverrideOpt The overridden imbalance tolerance ratio to be supplied to
   *                                      [[assertDesirableAssignmentProperties]].
   */
  private case class ReplicationTest(
      // Arguments for test setting up:
      description: String,
      predecessor: SliceMap[ProposedSliceAssignment],
      keyReplicationConfig: KeyReplicationConfig,
      imbalanceToleranceHint: ImbalanceToleranceHintP = ImbalanceToleranceHintP.DEFAULT,
      maxLoadHint: Double = 1000.0,
      churnConfig: ChurnConfig = ChurnConfig.DEFAULT,
      loadMapOverrideOpt: Option[LoadMap] = None,
      sliceReplicaAgeOverride: Map[(Slice, Squid), FiniteDuration] = Map.empty,
      availableResourcesOverrideOpt: Option[Resources] = None,
      // Arguments for result verification:
      expectedReplicas: Map[Slice, Either[Set[Squid], Int]] = Map.empty,
      expectedResourceLoads: Map[Squid, Double] = Map.empty,
      imbalanceToleranceOverrideOpt: Option[Double] = None) {

    /** Runs the test case as documented in the case class' comment. */
    def run(): Unit = {
      logger.info(s"Running test case: ${this.description}")

      // Setup: Create the predecessor assignment by committing the predecessor proposal provided by
      // the test case, and overriding the SubsliceAnnotations of the committed assignment with the
      // overridden continuous generation age.
      val predecessor: Assignment = {
        val committedProposal: Assignment = commitProposal(
          ProposedAssignment(predecessorOpt = None, this.predecessor)
        )
        // Converts the `sliceReplicaAgeOverride` parameter into a mutable slice map for easier
        // lookup. Slices appearing later in the map overlapped with former ones will override the
        // former ones.
        val mutableSliceMap = mutable
          .Map[Squid, MutableSliceMap[FiniteDuration]]()
          .withDefaultValue(new MutableSliceMap[FiniteDuration])
        for (entry <- this.sliceReplicaAgeOverride) {
          val ((slice, resource), age): ((Slice, Squid), FiniteDuration) = entry
          mutableSliceMap
            .getOrElseUpdate(resource, new MutableSliceMap[FiniteDuration])
            .put(slice, age)
        }
        val ageOverriddenSliceMap: SliceMap[SliceAssignment] =
          committedProposal.sliceMap.map(SliceMapHelper.SLICE_ASSIGNMENT_ACCESSOR) {
            sliceAssignment: SliceAssignment =>
              val subsliceAnnotationsOverride = Map.newBuilder[Squid, Vector[SubsliceAnnotation]]
              val slice: Slice = sliceAssignment.slice
              for (resource: Squid <- sliceAssignment.resources) {
                mutableSliceMap(resource).lookUp(slice.lowInclusive) match {
                  case Some((sliceInMap: Slice, age: FiniteDuration))
                      if sliceInMap.contains(slice) =>
                    val continuousGenerationNumberOverride =
                      UnixTimeVersion(sliceAssignment.generation.number.value - age.toMillis)
                    subsliceAnnotationsOverride += resource -> Vector(
                      SubsliceAnnotation(
                        slice,
                        continuousGenerationNumberOverride,
                        stateTransferOpt = None
                      )
                    )
                  case _ => ()
                }
              }
              sliceAssignment | subsliceAnnotationsOverride.result()
          }
        committedProposal.copy(sliceMap = ageOverriddenSliceMap)
      }

      val targetConfig: InternalTargetConfig =
        createConfigForLoadBalancing(
          churnConfig = this.churnConfig,
          maxLoadHint = this.maxLoadHint,
          imbalanceToleranceHint = this.imbalanceToleranceHint
        ).copy(keyReplicationConfig = this.keyReplicationConfig)

      // Setup: Use the available resources specified by the test case if defined; Otherwise, assume
      // that all resources in the predecessor are available if the test case does not provide them.
      val resources: Resources = this.availableResourcesOverrideOpt
        .getOrElse(Resources.create(predecessor.assignedResources))

      // Setup: Use the specified LoadMap if defined, or create a load map from the predecessor,
      // since it is convenient to indicate load inline in our test cases.
      val loadMap: LoadMap = this.loadMapOverrideOpt.getOrElse(
        LoadMap
          .newBuilder()
          .putLoad(
            predecessor.sliceMap.entries.map { sliceAssignment: SliceAssignment =>
              LoadMap.Entry(sliceAssignment.slice, sliceAssignment.primaryRateLoadOpt.getOrElse(0))
            }: _*
          )
          .build()
      )

      // Setup: Run the algorithm!
      val assignment: Assignment =
        generateAssignment(Target(getSafeName), targetConfig, resources, predecessor, loadMap)

      // Verify: The resulting assignment has the desired common properties.
      assertDesirableAssignmentProperties(
        targetConfig,
        assignment,
        resources,
        imbalanceToleranceOverrideOpt = this.imbalanceToleranceOverrideOpt
      )
      // Verify: Fine-grained verifications specified by the test case.
      for (sliceWithReplicas <- this.expectedReplicas) {
        val (slice, expectedReplicasOrNum): (Slice, Either[Set[Squid], Int]) = sliceWithReplicas
        // Verify: Each slice in `this.expectedReplicas` should show up in the resulting
        // assignment with exactly matching boundaries and expected replicas / number of replicas.
        val sliceAssignment = assignment.sliceMap.lookUp(slice.lowInclusive)
        assert(
          sliceAssignment.slice == slice,
          s"Expect slice $slice to show up in the resulting assignment, but got " +
          s"${sliceAssignment.slice}. Test case: ${this.description}"
        )
        expectedReplicasOrNum match {
          case Left(expectedReplicas: Set[Squid]) =>
            assert(
              sliceAssignment.resources == expectedReplicas,
              s"Expected slice $slice to be assigned to ${expectedReplicas.mkString}, " +
              s"but got ${sliceAssignment.resources.mkString}. Test case: ${this.description}"
            )
          case Right(expectedNumReplicas: Int) =>
            assert(
              sliceAssignment.resources.size == expectedNumReplicas,
              s"Expected slice $slice to have $expectedNumReplicas replicas, but got " +
              s"${sliceAssignment.resources.size} replicas: " +
              s"${sliceAssignment.resources.mkString}. Test case: ${this.description}"
            )
        }
      }

      // Tracking the actual real (rather than adjusted) load per resource after the assignment.
      val assignmentLoadStats: AssignmentLoadStats =
        AssignmentLoadStats.calculateSelfTrackedLoadStats(assignment)
      val actualResourceLoads: Map[Squid, Double] = assignmentLoadStats.loadByResource

      for (sliceAssignment: SliceAssignment <- assignment.sliceAssignments) {
        if (!this.expectedReplicas.contains(sliceAssignment.slice)) {
          // Verify: Each slice not specified in `this.expectedReplicas` should have default
          // number of replicas: configured minReplicas or number of available resource, whichever
          // smaller.
          val expectedDefaultNumReplicas: Int =
            targetConfig.keyReplicationConfig.minReplicas.min(resources.availableResources.size)
          assert(
            sliceAssignment.resources.size == expectedDefaultNumReplicas,
            s"Expected slice ${sliceAssignment.slice} to have $expectedDefaultNumReplicas " +
            s"replicas, but got ${sliceAssignment.resources.size} replicas: " +
            s"${sliceAssignment.resources.mkString}. Test case: ${this.description}"
          )
        }
      }

      // Verify: the total real load on the resources specified in `expectedResourceLoads`.
      for (resourceWithExpectedValue <- this.expectedResourceLoads) {
        val (resource, expectedValue): (Squid, Double) = resourceWithExpectedValue
        assert(
          // Allow a small floating point error.
          Math.abs(actualResourceLoads(resource) - expectedValue) < 1e-10,
          s"Expected total actual value on resource $resource to be $expectedValue, " +
          s"but got ${actualResourceLoads(resource)}. Complete actual loads: " +
          s"${actualResourceLoads.mkString}. Test case: ${this.description}"
        )
      }
    }
  }

  test("Splits hottest slices until slices are no longer splittable") {
    // Test plan: Verify that the algorithm splits the hottest splittable Slices (where a
    // non-splittable Slice is a Slice that contains a single key). Verify this by running the
    // algorithm where the hottest Slice in the existing assignment is unsplittable (because it
    // contains only a single key) and where another hot Slice can only be split once, and checking
    // in the resulting assignment that other cooler Slices are split to get above the minimum
    // required count.

    val targetConfig: InternalTargetConfig =
      createConfigForLoadBalancing(ChurnConfig.DEFAULT, maxLoadHint = 100)
    val predecessor = createAssignment(
      generation = 42,
      consistencyMode = AssignmentConsistencyMode.Affinity,
      ("" -- 10) @@ 42 -> Seq("resource0"),
      (10 -- 11) @@ 42 -> Seq("resource1"), // unsplittable
      (11 -- 50) @@ 42 -> Seq("resource2"),
      (50 -- 52) @@ 42 -> Seq("resource3"), // can only be split once!
      (52 -- ∞) @@ 42 -> Seq("resource4")
    )
    val loadMap = LoadMap
      .newBuilder()
      .putLoad(
        LoadMap.Entry("" -- 10, 1.0),
        LoadMap.Entry(10 -- 11, 200.0),
        LoadMap.Entry(11 -- 50, 1.0),
        LoadMap.Entry(50 -- 52, 150.0),
        LoadMap.Entry(52 -- ∞, 1.0)
      )
      .build()

    // Run the algorithm and verify that the expected Slices are split.
    val resources: Resources =
      createResources("resource0", "resource1", "resource2", "resource3", "resource4")
    val assignment: Assignment =
      generateAssignment(target, targetConfig, resources, predecessor, loadMap)
    assert(assignment.sliceMap.entries.size == 160) // 32 Slices per resource
    val slices: Seq[Slice] = assignment.sliceMap.entries.map { sliceAssignment: SliceAssignment =>
      sliceAssignment.slice
    }
    // Verify that 50 -- 52 was split once.
    assert(slices.contains(50 -- 51))
    assert(slices.contains(51 -- 52))

    // Verify that the unsplittable 10 -- 11 was not split.
    assert(slices.contains(10 -- 11))
  }

  test("Splits only splittable slices") {
    // Test plan: Verify that only splittable slices get split, otherwise the algorithm does not
    // attempt to split them.

    val target = Target(getSafeName)
    val targetConfig: InternalTargetConfig =
      createConfigForLoadBalancing(ChurnConfig.DEFAULT, maxLoadHint = 1.0)
    val generation = createGeneration()
    val predecessor = createAssignment(
      generation,
      consistencyMode = AssignmentConsistencyMode.Affinity,
      ("" -- 10) @@ generation -> Seq("resource0"),
      (10 -- 11) @@ generation -> Seq("resource1"), // unsplittable
      (11 -- 50) @@ generation -> Seq("resource2"),
      (50 -- 52) @@ generation -> Seq("resource3"), // splittable only once
      (52 -- ∞) @@ generation -> Seq("resource4")
    )
    val loadMap = LoadMap
      .newBuilder()
      .putLoad(
        LoadMap.Entry("" -- 10, 0.0),
        LoadMap.Entry(10 -- 11, 1.0), // non-zero load but unsplittable
        LoadMap.Entry(11 -- 50, 0.0),
        LoadMap.Entry(50 -- 52, 1.0), // non-zero load but splittable only once
        LoadMap.Entry(52 -- ∞, 0.0)
      )
      .build()

    // Run the algorithm and verify that the resulting assignment has the expected Slices.
    val resources =
      createResources("resource0", "resource1", "resource2", "resource3", "resource4")
    val assignment: Assignment =
      generateAssignment(target, targetConfig, resources, predecessor, loadMap)
    val slicesWithLoad: Seq[(Slice, Double)] = assignment.sliceMap.entries.map {
      sliceAssignment: SliceAssignment =>
        (sliceAssignment.slice, sliceAssignment.primaryRateLoadOpt.get)
    }
    // Due to uniform load reservations, the Slices with "zero" load will nonetheless be split,
    // because they will have non-zero reserved load. In this test, check the split behavior only
    // for the Slices with non-zero load.

    // 10 -- 11 cannot be split any further.
    assert(slicesWithLoad.contains((10 -- 11, 1.0)))

    // 50 -- 52 is split in two.
    assert(slicesWithLoad.contains((50 -- 51, 0.5)))
    assert(slicesWithLoad.contains((51 -- 52, 0.5)))
  }

  test("Merges coldest slices to within MIN and MAX avg slice replicas per resource") {
    // Test plan: Verify that coldest slices are merged until the total slice replicas are within
    // `MIN_AVG_SLICE_REPLICAS` and `MAX_AVG_SLICE_REPLICAS` average slice replicas per resource,
    // and that the resource chosen for the merged slice is chosen to maximize availability while
    // also minimizing churn. Verify this by creating assignments with more than 64*|resources|
    // Slices, and verify that the expected Slices are merged. Examples are structured to test
    // various internal edge cases, which are discussed in the test case descriptions/comments.

    case class TestCase(
        description: String,
        predecessor: SliceMap[ProposedSliceAssignment],
        expected: SliceMap[ProposedSliceAssignment],
        resourcesOpt: Option[Seq[Squid]] = None)

    // Placeholder to use as a wildcard in expected assignments, indicating that the assigned
    // resource is not relevant to the test outcome. Used in test cases where available resources
    // are changing and its difficult to predict which resource will be assigned by the allocation
    // phase (which is not the focus of the current test).
    val wildcardResources: Seq[Squid] = Seq("wildcard-pod")

    val testCases = Seq(
      // Initial assignment has 65 Slices and one resource. Expected the first two Slices (which
      // have less load than other Slices) to be merged to get down to 64 Slices.
      TestCase(
        description = "First two Slices merged",
        predecessor = createProposal(
          (("" -- 10) -> Seq("pod-0")).withPrimaryRateLoad(5),
          ((10 -- 20) -> Seq("pod-0")).withPrimaryRateLoad(5),
          ((20 -- ∞) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 10)
        ),
        expected = createProposal(
          (("" -- 20) -> Seq("pod-0")).withPrimaryRateLoad(10),
          ((20 -- ∞) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 10)
        )
      ),
      // Like the previous case, but the last two Slices are merged instead of the first two.
      TestCase(
        description = "Last two Slices merged",
        predecessor = createProposal(
          (("" -- 6300) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 10),
          ((6300 -- 7000) -> Seq("pod-0")).withPrimaryRateLoad(5),
          ((7000 -- ∞) -> Seq("pod-0")).withPrimaryRateLoad(5)
        ),
        expected = createProposal(
          (("" -- 6300) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 10),
          ((6300 -- ∞) -> Seq("pod-0")).withPrimaryRateLoad(10)
        )
      ),
      // Like the previous case, but two Slices in the middle are merged.
      TestCase(
        description = "Middle Slices merged",
        predecessor = createProposal(
          (("" -- 10000) -> Seq("pod-0")).subdivide(32, primaryRateLoadPerSlice = 10),
          ((10000 -- 11000) -> Seq("pod-0")).withPrimaryRateLoad(5),
          ((11000 -- 12000) -> Seq("pod-0")).withPrimaryRateLoad(5),
          ((12000 -- ∞) -> Seq("pod-0")).subdivide(31, primaryRateLoadPerSlice = 10)
        ),
        expected = createProposal(
          (("" -- 10000) -> Seq("pod-0")).subdivide(32, primaryRateLoadPerSlice = 10),
          ((10000 -- 12000) -> Seq("pod-0")).withPrimaryRateLoad(10),
          ((12000 -- ∞) -> Seq("pod-0")).subdivide(31, primaryRateLoadPerSlice = 10)
        )
      ),
      // When merging two Slices that belong to different resources, the merged Slice should be
      // assigned to the resource that has the larger share of the load (this heuristic minimizes
      // churn).
      TestCase(
        description = "Middle Slices merged, first resource has more load",
        predecessor = createProposal(
          (("" -- 0x10000) -> Seq("pod-0")).subdivide(64, primaryRateLoadPerSlice = 10),
          ((0x10000 -- 0x11000) -> Seq("pod-1")).withPrimaryRateLoad(8),
          ((0x11000 -- 0x12000) -> Seq("pod-0")).withPrimaryRateLoad(4),
          ((0x12000 -- ∞) -> Seq("pod-1")).subdivide(63, primaryRateLoadPerSlice = 10)
        ),
        expected = createProposal(
          (("" -- 0x10000) -> Seq("pod-0")).subdivide(64, primaryRateLoadPerSlice = 10),
          ((0x10000 -- 0x12000) -> Seq("pod-1")).withPrimaryRateLoad(12),
          ((0x12000 -- ∞) -> Seq("pod-1")).subdivide(63, primaryRateLoadPerSlice = 10)
        )
      ),
      TestCase(
        description = "Middle Slices merged, second resource has more load",
        predecessor = createProposal(
          (("" -- 0x10000) -> Seq("pod-0")).subdivide(64, primaryRateLoadPerSlice = 10),
          ((0x10000 -- 0x11000) -> Seq("pod-1")).withPrimaryRateLoad(4),
          ((0x11000 -- 0x12000) -> Seq("pod-0")).withPrimaryRateLoad(8),
          ((0x12000 -- ∞) -> Seq("pod-1")).subdivide(63, primaryRateLoadPerSlice = 10)
        ),
        expected = createProposal(
          (("" -- 0x10000) -> Seq("pod-0")).subdivide(64, primaryRateLoadPerSlice = 10),
          ((0x10000 -- 0x12000) -> Seq("pod-0")).withPrimaryRateLoad(12),
          ((0x12000 -- ∞) -> Seq("pod-1")).subdivide(63, primaryRateLoadPerSlice = 10)
        )
      ),

      // Repeatedly merging Slices should not cause any problems.
      TestCase(
        description = "Repeatedly merging Slices",
        predecessor = createProposal(
          (("" -- 0x40000) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 100),
          ((0x40000 -- 0x50000) -> Seq("pod-0")).withPrimaryRateLoad(20),
          ((0x50000 -- 0x60000) -> Seq("pod-0")).withPrimaryRateLoad(10),
          ((0x60000 -- ∞) -> Seq("pod-0")).withPrimaryRateLoad(30)
        ),
        expected = createProposal(
          (("" -- 0x40000) -> Seq("pod-0")).subdivide(63, primaryRateLoadPerSlice = 100),
          ((0x40000 -- ∞) -> Seq("pod-0")).withPrimaryRateLoad(60) // 0x50000 then 0x60000 removed
        )
      )
    )
    for (testCase <- testCases) {
      val predecessor: Assignment =
        commitProposal(ProposedAssignment(predecessorOpt = None, testCase.predecessor))
      // Disable churn penalties, since they make reasoning about the load more challenging.
      val config: InternalTargetConfig =
        createConfigForLoadBalancing(ChurnConfig.ZERO_PENALTY, maxLoadHint = 1)

      // Assume that all resources in the predecessor are available if the test case does not
      // provide them.
      val resources =
        Resources.create(testCase.resourcesOpt.getOrElse(predecessor.assignedResources))

      // Create a load map from the predecessor, since it is convenient to indicate load inline
      // in our test cases.
      val loadMap = LoadMap
        .newBuilder()
        .putLoad(
          predecessor.sliceMap.entries.map { sliceAssignment: SliceAssignment =>
            LoadMap.Entry(sliceAssignment.slice, sliceAssignment.primaryRateLoadOpt.getOrElse(0))
          }: _*
        )
        .build()

      // Run the algorithm!
      val actual: Assignment =
        generateAssignment(Target(getSafeName), config, resources, predecessor, loadMap)
      for (pair <- actual.sliceMap.entries.zip(testCase.expected.entries)) {
        val (actualSlice, expectedSlice): (SliceAssignment, ProposedSliceAssignment) =
          pair
        if (expectedSlice.resources != wildcardResources.toSet) {
          assert(actualSlice.resources == expectedSlice.resources, testCase.description)
        }
        assert(actualSlice.slice == expectedSlice.slice, testCase.description)
      }
    }
  }

  test("Reassigns slices from unhealthy to healthy resources: multiple asn rounds") {
    // Test plan: Verify that the algorithm reassigns slices from unhealthy to healthy resources
    // across multiple rounds of assignment generation.
    //
    // Verify this with the following schedule of available resources:
    //
    // - resource0, resource1, resource2             (start with 3 healthy resources)
    // -            resource1,          , resource3  (two resources become unhealthy + new resource)
    // - resource0, resource1,          , resource3  (unhealthy resource comes back)
    // - resource0, resource1                        (new resource becomes unhealthy)
    //
    // Verify at each step that the set of slices is assigned to the current set of healthy
    // resources (and generally satisfies desirable properties).
    val targetConfig: InternalTargetConfig = defaultTargetConfig
    var resources: Resources = createResources("resource0", "resource1", "resource2")
    val assignment1: Assignment =
      generateInitialAssignment(target, resources, targetConfig.keyReplicationConfig)
    assertDesirableAssignmentProperties(targetConfig, assignment1, resources)

    // Remove (i.e. make unhealthy) resource1, resource2, add resource3.
    resources = createResources("resource1", "resource3")
    // Load doesn't matter for this test.
    val loadMap: LoadMap = LoadMap.UNIFORM_LOAD_MAP
    val assignment2: Assignment =
      generateAssignment(target, targetConfig, resources, assignment1, loadMap)
    assertDesirableAssignmentProperties(targetConfig, assignment2, resources)

    // Add back resource0.
    resources = createResources("resource0", "resource1", "resource3")
    val assignment3: Assignment =
      generateAssignment(target, targetConfig, resources, assignment2, loadMap)
    assertDesirableAssignmentProperties(targetConfig, assignment3, resources)

    // Remove resource3.
    resources = createResources("resource0", "resource1")
    val assignment4: Assignment =
      generateAssignment(target, targetConfig, resources, assignment2, loadMap)
    assertDesirableAssignmentProperties(targetConfig, assignment4, resources)
  }

  test("Resource effective load is zero when all slices are removed") {
    // Test plan: Verify that the effective load tracked for a resource is computed to be zero when
    // all of the slices assigned to it are removed. Verify this by creating an assignment where
    // slices are assigned to pod0 and pod1 in an alternating fashion, the slices assigned to pod0
    // are very slightly hotter than the slices assigned to pod1, and where the total number of
    // slices exceeds the max so that the algo merges all pairs of slices away from pod1. Check that
    // even when the min desired load is Double.MinPositiveValue (the algo uses
    // Double.MinPositiveValue to ensure it always assigns all resources at least once slice when
    // the min desired load is effectively zero) the algo still assigns slices to pod1, confirming
    // that pod1's load was zero after all slices were removed, causing the algorithm to assign
    // slices to it.
    //
    // This is a regression test for a bug where the load of a resource after all slices were
    // removed would be non-zero and greater than Double.MinPositiveValue due to floating point
    // errors, causing the algorithm to think it didn't need to migrate anything to it in the
    // migration phase when min desired load was effectively zero.

    val proposedAsnBuilder = Vector.newBuilder[ProposedAssignmentEntry]
    var prevKey: SliceKey = ""
    val resource1: Squid = "pod0"
    val resource2: Squid = "pod1"
    val resources: Resources = Resources.create(Seq(resource1, resource2))
    // Algo allows up to 64 slices per resource. Creating 256 over 2 resources will cause it to
    // merge until there are 128 slices.
    for (index <- 0 until 256) {
      val slice = (prevKey -- index)
      if (index % 2 == 0) {
        proposedAsnBuilder += ((prevKey -- index) -> Seq(resource1)).withPrimaryRateLoad(10.00001)
      } else {
        proposedAsnBuilder += ((prevKey -- index) -> Seq(resource2)).withPrimaryRateLoad(9.99999)
      }
      prevKey = slice.highExclusive.asFinite
    }
    proposedAsnBuilder += ((prevKey -- ∞) -> Seq(resource1)).withPrimaryRateLoad(10.00001)
    val proposedAsn = proposedAsnBuilder.result()
    val predecessor: Assignment =
      commitProposal(
        ProposedAssignment(
          predecessorOpt = None,
          createProposal(proposedAsn.head, proposedAsn.tail: _*)
        )
      )
    // Setting maxLoadHint to Int.MaxValue here to ensure that min desired load gets computed as
    // effectively zero (Double.MinPositiveValue to ensure that at least something gets assigned to
    // all resources).
    val config: InternalTargetConfig =
      createConfigForLoadBalancing(ChurnConfig.ZERO_PENALTY, maxLoadHint = Int.MaxValue)

    val loadMap = LoadMap
      .newBuilder()
      .putLoad(
        predecessor.sliceAssignments.map { sliceAssignment: SliceAssignment =>
          LoadMap.Entry(sliceAssignment.slice, sliceAssignment.primaryRateLoadOpt.getOrElse(0))
        }: _*
      )
      .build()
    val result: Assignment =
      generateAssignment(target, config, resources, predecessor, loadMap)
    assert(result.assignedResources == resources.availableResources)
  }



  test("Ramp up with no load reported and default load balancing configuration") {
    // Test plan: Verify that the algorithm produces valid assignments that are well-balanced and
    // doesn't crash when no load is reported. Verify this by simulating ramping up then ramping
    // down the number of pods in an assignment to give the code some exercise.
    //
    // This test models a default configured application which is ramping up but not yet reporting
    // any load. In this case the application will have the default load balancing configuration
    // which applies a uniform load reservation amounting to 1% of the configured maxLoadHint.

    val targetConfig: InternalTargetConfig =
      createConfigForLoadBalancing(ChurnConfig.DEFAULT, maxLoadHint = 100)
    val loadMap = LoadMap.newBuilder().build()
    assert(loadMap.getLoad(Slice.FULL) == 0.0)

    // Create an initial assignment with 2 resources. We use `assertDesirableAssignmentProperties`,
    // which accounts for the uniform-load reservation, to verify that the assignments generated in
    // this test are well balanced.
    val assignment1: Assignment =
      generateInitialAssignment(target, createNResources(2), targetConfig.keyReplicationConfig)
    assertDesirableAssignmentProperties(targetConfig, assignment1, createNResources(2))

    // Update the assignment to include 4 resources.
    val assignment2: Assignment =
      generateAssignment(target, targetConfig, createNResources(4), assignment1, loadMap)
    assertDesirableAssignmentProperties(targetConfig, assignment2, createNResources(4))

    // Update the assignment to include 3 resources.
    val assignment3: Assignment =
      generateAssignment(target, targetConfig, createNResources(3), assignment2, loadMap)
    assertDesirableAssignmentProperties(targetConfig, assignment3, createNResources(3))
  }

  test("Algorithm.Config computes the expected split threshold") {
    // Test plan: Verify that Algorithm.Config computes the appropriate split threshold based on the
    // target's maxLoadHint, imbalanceToleranceHint and the average load per resource. Verify this
    // by constructing several such configs and checking that the computed split threshold meets
    // expectations.

    case class TestCase(
        maxLoadHint: Double,
        imbalanceToleranceHintP: ImbalanceToleranceHintP,
        totalLoad: Double,
        numResources: Int,
        expectedSplitThreshold: Double)
    val testCases = Seq[TestCase](
      // Total load is well below maxLoadHint * numResources. Using the default imbalance tolerance
      // hint, the split threshold should be 10% of maxLoadHint.
      TestCase(
        maxLoadHint = 100.0,
        imbalanceToleranceHintP = ImbalanceToleranceHintP.DEFAULT,
        totalLoad = 1000.0,
        numResources = 20,
        expectedSplitThreshold = 10.0
      ),
      // As above, but with TIGHT tolerance. The split threshold should be 2.5% of maxLoadHint.
      TestCase(
        maxLoadHint = 100.0,
        imbalanceToleranceHintP = ImbalanceToleranceHintP.TIGHT,
        totalLoad = 1000.0,
        numResources = 20,
        expectedSplitThreshold = 2.5
      ),
      // As above, but with LOOSE tolerance. The split threshold should be 40% of maxLoadHint.
      TestCase(
        maxLoadHint = 100.0,
        imbalanceToleranceHintP = ImbalanceToleranceHintP.LOOSE,
        totalLoad = 1000.0,
        numResources = 20,
        expectedSplitThreshold = 40.0
      ),
      // When the total load exceeds maxLoadHint * numResources, the split threshold should be
      // relative to the actual average load per resource. Using the default imbalance tolerance,
      // the split threshold should be 10% of the average load per resource.
      TestCase(
        maxLoadHint = 10.0,
        imbalanceToleranceHintP = ImbalanceToleranceHintP.DEFAULT,
        totalLoad = 1000.0,
        numResources = 20,
        expectedSplitThreshold = 5.0
      )
    )
    for (testCase <- testCases) {
      val loadBalancingMetricConfig = LoadBalancingMetricConfig(
        imbalanceToleranceHint = testCase.imbalanceToleranceHintP,
        maxLoadHint = testCase.maxLoadHint
      )
      val loadBalancingConfig = LoadBalancingConfig(
        loadBalancingInterval = 1.minute, // does not affect the current test case
        ChurnConfig.DEFAULT,
        primaryRateMetric = loadBalancingMetricConfig
      )
      val config = Algorithm.Config.create(
        target = Target(getSafeName),
        loadBalancingConfig,
        KeyReplicationConfig.DEFAULT_SINGLE_REPLICA,
        testCase.numResources,
        testCase.totalLoad
      )
      assert(
        config.desiredLoadRange.splitThreshold == testCase.expectedSplitThreshold,
        s"unexpected split threshold for test case: $testCase"
      )
    }
  }

  test("calculateDesiredLoadRange requires number of resources to be positive") {
    // Test plan: Verify that `calculateDesiredLoadRange` checks that the number of resources is
    // positive.
    val targetConfig: InternalTargetConfig =
      createConfigForLoadBalancing(ChurnConfig.ZERO_PENALTY, maxLoadHint = 1)

    assertThrow[IllegalArgumentException]("numResources must be positive") {
      Algorithm.calculateDesiredLoadRange(
        targetConfig.loadBalancingConfig,
        numResources = 0,
        totalAdjustedLoad = 1.0
      )
    }
    assertThrow[IllegalArgumentException]("numResources must be positive") {
      Algorithm.calculateDesiredLoadRange(
        targetConfig.loadBalancingConfig,
        numResources = -1,
        totalAdjustedLoad = 1.0
      )
    }

    Algorithm.calculateDesiredLoadRange(
      targetConfig.loadBalancingConfig,
      numResources = 1,
      totalAdjustedLoad = 1.0
    )
  }

  test("DesiredLoadRange validation") {
    // Test plan: Verify that Algorithm.DesiredLoadRange rejects invalid parameters. Verify this by
    // creating a valid DesiredLoadRange and tweaking its fields and verifying proper exceptions
    // are thrown.

    val valid = Algorithm.DesiredLoadRange(
      splitThreshold = 100.0,
      minDesiredLoadExistingResource = 90.0,
      minDesiredLoadNewResource = 200.0,
      maxDesiredLoad = 500.0
    )
    assertThrow[IllegalArgumentException]("splitThreshold must be positive") {
      valid.copy(splitThreshold = -100.0)
    }
    assertThrow[IllegalArgumentException]("splitThreshold must be positive") {
      valid.copy(splitThreshold = 0.0)
    }
    assertThrow[IllegalArgumentException]("minDesiredLoadNewResource must be positive") {
      valid.copy(minDesiredLoadNewResource = -100.0)
    }
    assertThrow[IllegalArgumentException]("minDesiredLoadNewResource must be positive") {
      valid.copy(minDesiredLoadNewResource = 0.0)
    }
    assertThrow[IllegalArgumentException]("minDesiredLoadExistingResource must be positive") {
      valid.copy(minDesiredLoadExistingResource = -100.0)
    }
    assertThrow[IllegalArgumentException]("minDesiredLoadExistingResource must be positive") {
      valid.copy(minDesiredLoadExistingResource = 0.0)
    }
    assertThrow[IllegalArgumentException](
      "maxDesiredLoad must be greater than or equal to minDesiredLoadExistingResource"
    ) {
      valid.copy(minDesiredLoadExistingResource = 100.0, maxDesiredLoad = 50.0)
    }
    assertThrow[IllegalArgumentException](
      "maxDesiredLoad must be greater than or equal to minDesiredLoadNewResource"
    ) {
      valid.copy(
        minDesiredLoadNewResource = 100.0,
        minDesiredLoadExistingResource = 50,
        maxDesiredLoad = 50.0
      )
    }
  }




}
