package com.databricks.dicer.assigner

import scala.concurrent.Future
import scala.util.Random

import io.grpc.Status

import com.databricks.caching.util.{Cancellable, SequentialExecutionContext, ValueStreamCallback}
import com.databricks.dicer.assigner.ShadowEtcdStore.ShadowAssignmentWriteResult
import com.databricks.dicer.common.{Assignment, Incarnation, ProposedAssignment}
import com.databricks.caching.util.EtcdClient
import com.databricks.dicer.external.Target

/**
 * Store that behaves like [[InMemoryStore]] but additionally writes all assignments asynchronously
 * to [[EtcdStore]]. ONLY assignments generated by the [[InMemoryStore]] are distributed.
 *
 * [[inMemoryStoreIncarnation]] is used for [[InMemoryStore]].
 */
class ShadowEtcdStore(
    sec: SequentialExecutionContext,
    etcdClient: EtcdClient,
    etcdStoreIncarnation: Incarnation,
    inMemoryStoreIncarnation: Incarnation)
    extends Store {

  /** [[EtcdStore]], used ONLY for asynchronous write operations. */
  private val etcdStore =
    EtcdStore.create(sec, etcdClient, EtcdStoreConfig.create(etcdStoreIncarnation), new Random())

  /** [[InMemoryStore]], used for all store operations. */
  private val inMemoryStore = InMemoryStore(sec, inMemoryStoreIncarnation)

  override val storeIncarnation: Incarnation = inMemoryStore.storeIncarnation

  override def watchAssignments(
      target: Target,
      callback: ValueStreamCallback[Assignment]): Cancellable = {

    // Create a no-op watch against assignments from the etcdStore so that we exercise the watch
    // code path and generate traffic against etcd. It's fine to ignore the onSuccess callbacks
    // because we also watch the InMemoryStore and only care about those results. Assignments
    // written to EtcdStore track different generations and are not visible outside of the Store.
    val etcdStoreCancellable =
      etcdStore.watchAssignments(target, new ValueStreamCallback[Assignment](sec) {
        override protected def onSuccess(value: Assignment): Unit = {}
      })

    // Watch assignments in the in memory store using the providing callback .
    val inMemoryStoreCancellable = inMemoryStore.watchAssignments(target, callback)

    // Return a cancellable that cancels both the watches.
    val cancellable: Cancellable =
      (reason: Status) => {
        etcdStoreCancellable.cancel(reason)
        inMemoryStoreCancellable.cancel(reason)
      }
    cancellable
  }

  /**
   * See [[Store.writeAssignment]], but writes the assignment to both the [[inMemoryStore]] and
   * [[etcdStore]] separately and asynchronously, and returns the Future of the write result for the
   * InMemoryStore. The write result for EtcdStore is ignored and discarded.
   */
  override def writeAssignment(
      target: Target,
      shouldFreeze: Boolean,
      proposal: ProposedAssignment): Future[Store.WriteAssignmentResult] = {
    writeAssignmentToInMemoryAndEtcdStore(
      target,
      shouldFreeze,
      proposal
    ).inMemoryStoreWriteResult
  }

  override def informAssignment(target: Target, assignment: Assignment): Unit = {
    // Inform about the assignment from trusted authority to both the stores. Assignments in
    // distribution may belong to store incarnations of either the InMemoryStore or EtcdStore. Each
    // store is expected to learn assignments only from its own store incarnation. Since the two
    // stores have different store incarnations, any assignment will be ignored by at least one of
    // the stores.
    etcdStore.informAssignment(target, assignment)
    inMemoryStore.informAssignment(target, assignment)
  }

  override def getLatestKnownAssignment(target: Target): Future[Option[Assignment]] = {
    inMemoryStore.getLatestKnownAssignment(target)
  }

  /**
   * Internal implementation of [[writeAssignment]], which writes the assignment to both the
   * [[inMemoryStore]] and [[etcdStore]] separately and asynchronously, and returns a
   * [[ShadowAssignmentWriteResult]] containing the InMemoryStore write result and the EtcdStore
   * write result.
   */
  private def writeAssignmentToInMemoryAndEtcdStore(
      target: Target,
      shouldFreeze: Boolean,
      proposal: ProposedAssignment): ShadowAssignmentWriteResult = {
    // Write an assignment to EtcdStore asynchronously.

    // Build a new proposal using latest assignment from EtcdStore as the predecessor if it exists
    // and has the same incarnation as the EtcdStore. We do this, since EtcdStore uses separate
    // generations and store only reveals assignments from InMemoryStore.
    val etcdStoreWriteResultFut: Future[Store.WriteAssignmentResult] =
      etcdStore
        .getLatestKnownAssignment(target)
        .flatMap { etcdAssignment: Option[Assignment] =>
          val predecessorOpt = etcdAssignment.filter { latestKnownAssignment =>
            latestKnownAssignment.generation.incarnation == etcdStoreIncarnation
          }
          val etcdProposal = proposal.copy(predecessorOpt = predecessorOpt)
          etcdStore.writeAssignment(target, shouldFreeze, etcdProposal)
        }(sec)
    val inMemoryStoreWriteResultFut: Future[Store.WriteAssignmentResult] =
      inMemoryStore.writeAssignment(target, shouldFreeze, proposal)
    ShadowEtcdStore.ShadowAssignmentWriteResult(
      inMemoryStoreWriteResultFut,
      etcdStoreWriteResultFut
    )
  }

  object forTest {

    /** Cancel the etcd watch for all targets known to the Store. */
    def cleanup(): Future[Unit] = {
      etcdStore.forTest.cleanup()
    }

    /** Underlying [[EtcdStore]] used by the [[ShadowEtcdStore]] */
    def etcdStore: EtcdStore = ShadowEtcdStore.this.etcdStore

    /** See [[ShadowEtcdStore.writeAssignmentToInMemoryAndEtcdStore]]. */
    def writeAssignmentToInMemoryAndEtcdStore(
        target: Target,
        shouldFreeze: Boolean,
        proposal: ProposedAssignment): ShadowAssignmentWriteResult = {
      ShadowEtcdStore.this.writeAssignmentToInMemoryAndEtcdStore(
        target,
        shouldFreeze,
        proposal
      )
    }
  }
}

object ShadowEtcdStore {

  /** Case class associating the results of writes to the InMemoryStore and EtcdStore. */
  case class ShadowAssignmentWriteResult(
      inMemoryStoreWriteResult: Future[Store.WriteAssignmentResult],
      etcdStoreWriteResult: Future[Store.WriteAssignmentResult])
}
