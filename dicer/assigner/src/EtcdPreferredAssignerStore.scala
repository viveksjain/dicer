package com.databricks.dicer.assigner

import scala.concurrent.{Future, Promise}
import com.databricks.caching.util.{
  Cancellable,
  PrefixLogger,
  SequentialExecutionContext,
  StateMachineDriver,
  StreamCallback,
  WatchValueCell
}
import com.databricks.dicer.assigner.EtcdPreferredAssignerStore.{
  PreferredAssignerProposal,
  WriteResult
}
import com.databricks.dicer.assigner.EtcdPreferredAssignerStoreStateMachine.{
  DriverAction,
  Event,
  StoreErrorReason
}
import com.databricks.dicer.assigner.PreferredAssignerValue.PreferredAssignerWatchCellConsumer
import com.databricks.caching.util.EtcdClient
import com.databricks.caching.util.EtcdClient.{Version, WatchArgs}
import com.databricks.dicer.common.{EtcdClientHelper, Generation, Incarnation}

import scala.concurrent.duration.{Duration, FiniteDuration}
import scala.concurrent.duration._
import scala.util.{Random, Try}
import io.grpc.Status

/**
 * See [[EtcdPreferredAssignerStore.Impl]] for the production implementation.
 *
 * Preferred assigner store with etcd as the underlying storage for Dicer.
 *
 * The store supports writing and watching the current [[PreferredAssignerValue]].
 *
 * The store locally caches the latest known preferred assigner. The `informPreferredAssigner`
 * method allows the cached value to be updated with more recent values received from other
 * trusted components.
 *
 * The store is also responsible for choosing generations for preferred assigners. The assigner is
 * initialized with a single store and store incarnation. Each store only understands and generates
 * assignments from the designated store incarnation (i.e. at no point should a store write or
 * report a preferred assigner from a different store incarnation).
 *
 * Preferred assigner generations generated by [[EtcdPreferredAssignerStore]] implementations are
 * REQUIRED to set the upper 64 bits of the preferred assigner generation incarnation to the store
 * incarnation, which enables maintaining monotonicity of preferred assigner generations across
 * store incarnations:
 *
 * |----------- incarnation (64 bits) --------|----------- generation (64 bits) ------------|
 * +------------------------------------------+---------------------------------------------+
 * |-------- StoreIncarnation (64 bits) ------|               chosen by store               |
 * +------------------------------------------+---------------------------------------------+
 *
 * For more information on the preferred assigner design, see <internal link>.
 */
trait EtcdPreferredAssignerStore {

  def storeIncarnation: Incarnation

  /** Gets the watch cell for the [[PreferredAssignerValue]]. */
  def getPreferredAssignerWatchCell: PreferredAssignerWatchCellConsumer

  /**
   * REQUIRES: `preferredAssignerProposal.predecessorGenerationOpt` is empty or belongs to the
   * same incarnation as `storeIncarnation`.
   *
   * Attempts to set the current preferred assigner with OCC checks. See [[WriteResult]] for
   * possible outcomes of this operation. If `preferredAssignerProposal.predecessorGenerationOpt`
   * is None, the store will check that there is no existing preferred assigner, and if there is,
   * the store will retry the write internally with the proper predecessor's generation.
   *
   * @param preferredAssignerProposal The proposal to set the preferred assigner.
   */
  def write(preferredAssignerProposal: PreferredAssignerProposal): Future[WriteResult]

  /**
   * Informs the store of a preferred assigner received from a trusted authority (e.g.,
   * another Assigner). The store may or may not incorporate that information depending on whether
   * it belongs to the same incarnation as the store and is fresher than the cached value.
   *
   * This method allows the store to keep its cached value fresh even when it is unable to receive
   * watch updates from the underlying consistent store because of a driver or network issue.
   */
  def informPreferredAssigner(preferredAssigner: PreferredAssignerValue): Unit
}

object EtcdPreferredAssignerStore {

  /**
   * The key of the preferred assigner record in etcd. This must be unique in the store; e.g. it
   * should not equal the key used for any assignment.
   */
  private val KEY: String = "_preferred_assigner_"

  /** The default configuration for [[EtcdPreferredAssignerStore]]. */
  val DEFAULT_CONFIG: this.Config =
    this.Config(minWatchRetryDelay = 5.seconds, maxWatchRetryDelay = 30.seconds)

  /**
   * A proposal to set the preferred assigner to `assignerInfoOpt` with Occ checks based on the
   * predecessor.
   *
   * @param predecessorGenerationOpt    The predecessor generation, or None if the caller believes
   *                                    there is no predecessor in the store.
   * @param newPreferredAssignerInfoOpt The proposed new preferred assigner, or None if the caller
   *                                    believes no assigner is currently preferred.
   * @note the proposal does not include the generation because that is chosen by the store.
   */
  case class PreferredAssignerProposal(
      predecessorGenerationOpt: Option[Generation],
      newPreferredAssignerInfoOpt: Option[AssignerInfo]) {

    override def toString: String = {
      s"(predecessor generation $predecessorGenerationOpt, " +
      s"new preferred assigner $newPreferredAssignerInfoOpt)"
    }
  }

  /** Possible outcomes of a [[EtcdClient.write()]] request. */
  trait WriteResult

  object WriteResult {

    /**
     * Indicates that the write failed because the actual preferred assigner in the underlying
     * consistent store did not match the supplied predecessor. Returns the existing preferred
     * assigner generation discovered during the failed write. [[Generation.EMPTY]] indicates that
     * there is no value present.
     */
    case class OccFailure(existingPreferredAssignerGeneration: Generation) extends WriteResult

    /**
     * Indicates that the preferred assigner proposal was successfully written to the store.
     *
     * The returned [[PreferredAssignerValue]] includes the generation number chosen by the store
     * and the optional assigner information from the proposal.
     */
    case class Committed(committedPreferredAssigner: PreferredAssignerValue) extends WriteResult
  }

  /**
   * REQUIRES: 0 < minWatchRetryDelay < maxWatchRetryDelay < 5 minutes
   *
   * Configuration for the preferred assigner store.
   *
   * @param minWatchRetryDelay Minimum retry delay for Etcd watch exponential backoff.
   * @param maxWatchRetryDelay Maximum retry delay for Etcd watch exponential backoff.
   */
  case class Config(minWatchRetryDelay: FiniteDuration, maxWatchRetryDelay: FiniteDuration) {
    require(Duration.Zero < minWatchRetryDelay)
    require(minWatchRetryDelay < maxWatchRetryDelay)
    require(maxWatchRetryDelay < 5.minutes)
  }

  def create(
      storeIncarnation: Incarnation,
      client: EtcdClient,
      random: Random,
      config: EtcdPreferredAssignerStore.Config = EtcdPreferredAssignerStore.DEFAULT_CONFIG,
      sec: SequentialExecutionContext =
        SequentialExecutionContext.createWithDedicatedPool("preferred-assigner-store")
  ): EtcdPreferredAssignerStore = {
    Impl.create(sec, storeIncarnation, client, random, config)
  }

  /**
   * REQUIRES: `storeIncarnation` is non-loose.
   * The production implementation of [[EtcdPreferredAssignerStore]]. Separated from the trait to
   * allow tests to override methods.
   */
  private[assigner] final class Impl private (
      sec: SequentialExecutionContext,
      val storeIncarnation: Incarnation,
      client: EtcdClient,
      random: Random,
      config: EtcdPreferredAssignerStore.Config)
      extends EtcdPreferredAssignerStore {
    require(
      storeIncarnation.isNonLoose,
      f"Store incarnation must be non-loose ($storeIncarnation)."
    )

    private val logger = PrefixLogger.create(this.getClass, s"dicer-preferred-assigner")

    /** Cancellation handle for the watch on the etcd store. */
    private var etcdWatchHandleOpt: Option[Cancellable] = None

    /**
     * A watch cell containing the latest value of the preferred assigner known by this store.
     *
     * No values will be yielded until at least one write to the store has occurred or until
     * [[informPreferredAssigner()]] has been called.
     */
    private val preferredAssignerCell = new WatchValueCell[PreferredAssignerValue]

    /** Generic driver implementation that drives the [[EtcdPreferredAssignerStoreStateMachine]]. */
    private val baseDriver =
      new StateMachineDriver[Event, DriverAction, EtcdPreferredAssignerStoreStateMachine](
        sec,
        new EtcdPreferredAssignerStoreStateMachine(storeIncarnation, random, config),
        performAction
      )

    def getPreferredAssignerWatchCell: PreferredAssignerWatchCellConsumer = {
      // No `sec` is needed here because the `preferredAssignerCell` is thread-safe.
      preferredAssignerCell
    }

    override def write(preferredAssignerProposal: PreferredAssignerProposal): Future[WriteResult] =
      sec.flatCall {
        val promise = Promise[WriteResult]()
        baseDriver.handleEvent(Event.WriteRequest(promise, preferredAssignerProposal))
        promise.future
      }

    override def informPreferredAssigner(preferredAssigner: PreferredAssignerValue): Unit =
      sec.run {
        baseDriver.handleEvent(Event.PreferredAssignerInformed(preferredAssigner))
      }

    /** Starts the driver. */
    private def start(): Unit = {
      sec.assertCurrentContext()
      baseDriver.start()
    }

    /**
     * Performs an action requested of this driver by the
     * [[EtcdPreferredAssignerStoreStateMachine]].
     */
    private def performAction(action: DriverAction): Unit = {
      sec.assertCurrentContext()

      action match {
        case DriverAction.ApplyPreferredAssigner(preferredAssigner: PreferredAssignerValue) =>
          logger.info(s"Applying preferred assigner $preferredAssigner to the local cache.")
          preferredAssignerCell.setValue(preferredAssigner)

        case DriverAction
              .CompleteWrite(promise: Promise[WriteResult], response: Try[WriteResult]) =>
          logger.info(s"Completing write request with response $response.")
          promise.complete(response)

        case DriverAction.CancelEtcdWatch(reason: StoreErrorReason) =>
          // If the watch is already cancelled, we may not have a watch handle entry.
          if (etcdWatchHandleOpt.isDefined) {
            logger.info(s"Cancelling the Etcd watch with reason $reason")
            etcdWatchHandleOpt.get.cancel(reason.status)
            etcdWatchHandleOpt = None
          }

        case DriverAction.WritePreferredAssignerToEtcd(
            promise: Promise[WriteResult],
            predecessorVersionOpt: Option[Version],
            preferredAssigner: PreferredAssignerValue
            ) =>
          logger.info(
            s"Write preferred assigner=$preferredAssigner with " +
            s"predecessorVersionOpt=$predecessorVersionOpt to etcd."
          )
          val future: Future[EtcdClient.WriteResponse] =
            client.write(
              EtcdPreferredAssignerStore.KEY,
              EtcdClientHelper.getVersionFromNonLooseGeneration(preferredAssigner.generation),
              value = preferredAssigner.toSpecProto.toByteString,
              predecessorVersionOpt,
              isIncremental = false // No incremental writes are needed.
            )
          future.onComplete(
            response =>
              baseDriver.handleEvent(
                Event.EtcdWriteResponse(promise, predecessorVersionOpt, preferredAssigner, response)
              )
          )(sec)

        case DriverAction.PerformEtcdWatch(watchDuration: Duration) =>
          if (etcdWatchHandleOpt.isEmpty) {
            etcdWatchHandleOpt = Some(
              client.watch(
                WatchArgs(EtcdPreferredAssignerStore.KEY, watchDuration = watchDuration),
                new StreamCallback[EtcdClient.WatchEvent](sec) {
                  override protected def onSuccess(value: EtcdClient.WatchEvent): Unit = {
                    baseDriver.handleEvent(Event.EtcdWatchEvent(value))
                  }

                  override protected def onFailure(status: Status): Unit = {
                    etcdWatchHandleOpt = None
                    baseDriver.handleEvent(Event.EtcdWatchFailure(status))
                  }
                }
              )
            )
          }
      }
    }
  }
  object Impl {
    def create(
        sec: SequentialExecutionContext,
        storeIncarnation: Incarnation,
        client: EtcdClient,
        random: Random,
        config: EtcdPreferredAssignerStore.Config
    ): Impl = {
      val driver = new Impl(sec, storeIncarnation, client, random, config)
      sec.run { driver.start() }
      driver
    }
  }

  object ForTest {

    /** The key for the preferred assigner value in the etcd store. */
    def key: String = KEY
  }
}
