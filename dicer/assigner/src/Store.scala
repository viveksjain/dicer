package com.databricks.dicer.assigner

import scala.concurrent.Future

import com.databricks.caching.util.{Cancellable, ValueStreamCallback}
import com.databricks.dicer.common.{Assignment, Generation, Incarnation, ProposedAssignment}
import com.databricks.dicer.external.Target

/**
 * Storage layer for Dicer. Supports writing assignments, and watching assignments. The storage
 * layer also locally caches assignments, and an `informAssignment` method allows assignments
 * received from other trusted components to be incorporated into that cache. This is particularly
 * useful for the in-memory store that is the only implementation available to Dicer as of January
 * 2023, allowing recent assignments maintained in Slicelets to be fed back to the Assigner via the
 * assignment sync protocol.
 *
 * The Store is also responsible for choosing generations for assignments. The Assigner is
 * initialized with a single store and store incarnation. Assignment generations generated by
 * Store implementations are REQUIRED to set the upper 64 bits of the assignment generation
 * incarnation to the store incarnation.
 *
 * The single-store-incarnation-per-process policy makes it easier to reason about correctness,
 * particularly when we have two Assigners running with two different store incarnations e.g.,
 * during an update to the Assigner with a store incarnation change). We know that the Assigner with
 * older store incarnation will only be able to generate assignments with older store incarnation
 * and eventually Slicelets will only learn from the new Assigner with higher store incarnation.
 * This allows the team to generate and supersede any existing assignments by restarting the
 * Assigner with a higher incarnation number, which may be useful in case corrupted or otherwise
 * undesirable assignments get distributed.
 *
 * |----------- incarnation (64 bits) --------|----------- generation (64 bits) ------------|
 * +--------------------+---------------------+---------------------------------------------+
 * |------------ StoreInc (64 bits) --------- |               chosen by store               |
 * +--------------------+---------------------+---------------------------------------------+
 *
 * Note that, depending on the properties of the store implementation, other requirements on
 * incarnation numbers for assignments may need to be fulfilled (e.g. to support "non-loose"
 * assignment incarnations, see [[Incarnation]] for details).
 */
trait Store {
  import Store.WriteAssignmentResult

  /**
   * The store incarnation for all assignments written by this store. On the other hand, assignments
   * from any incarnation may be returned from [[watchAssignments()]].
   */
  val storeIncarnation: Incarnation

  /**
   * Watches assignments for the given `target`. Assignments are supplied to `callback` as they are
   * committed or read by this store until some time after the returned handle is cancelled.
   * Note that the callback is only guaranteed to eventually receive the latest assignment (the
   * assignment with the highest generation), not every intermediate version of the assignment.
   */
  def watchAssignments(target: Target, callback: ValueStreamCallback[Assignment]): Cancellable

  /**
   * REQUIRES: Predecessor in the proposal is either empty or has a store incarnation (set in the
   * assignment's incarnation number, see class comments) equal to this Store's configured store
   * incarnation.
   *
   * Attempts to commit the given `proposal` for `target`'s assignment to the store. Performs an OCC
   * check based on the generation of `proposal.predecessor` to ensure that the committed assignment
   * has the expected predecessor. When `predecessor` is None, the store checks that there is no
   * existing assignment. This OCC check is critical for correctness:
   *
   *  - Dicer distributes incremental assignments, a mechanism that would break if there were
   *    divergent assignment histories.
   *  - Dicer consistency relies on the ability to identify continuously assigned Slices, which
   *    would be broken if intervening assignments were blindly overwritten (see the discussion of
   *    assignment Slice generations in [[Assignment]] docs).
   *
   * `shouldFreeze` determines whether the written assignment should be flagged as frozen, which
   * will prevent the assignment generator from overwriting it.
   *
   * The store is responsible for assigning a generation to the assignment if it is committed. The
   * `proposal` does not have a generation. See class comments for requirements on choosing
   * generation numbers.
   *
   * See [[WriteAssignmentResult]] for possible outcomes of this operation.
   */
  def writeAssignment(
      target: Target,
      shouldFreeze: Boolean,
      proposal: ProposedAssignment): Future[WriteAssignmentResult]

  /**
   * Informs the store of an assignment received from a trusted authority (e.g., another Assigner or
   * a Slicelet). Based on the assignment's content and generation, the store may or may not
   * incorporate that assignment into its cached state.
   */
  def informAssignment(target: Target, assignment: Assignment): Unit

  /**
   * Returns the latest known assignment for the given `target`. Yields None if no assignment is
   * known. The returned assignment may be stale, as the latest cached assignment is returned
   * without consulting the underlying store. However, when using [[InMemoryStore]] (e.g., in
   * Dicer's test environment), results are guaranteed to be up-to-date.
   */
  def getLatestKnownAssignment(target: Target): Future[Option[Assignment]]
}

object Store {

  /** Possible outcomes of a [[Store.writeAssignment()]] request. */
  sealed trait WriteAssignmentResult

  object WriteAssignmentResult {

    /**
     * Indicates that writing failed because the existing assignment did not have the required
     * generation.
     *
     * @param existingAssignmentGeneration the generation of the actual assignment in the store at
     *                                     the time of the write attempt
     */
    case class OccFailure(existingAssignmentGeneration: Generation) extends WriteAssignmentResult

    /**
     * Indicates that the proposed assignment was successfully written to the store.
     *
     * @param assignment the committed assignment, which is the proposed assignment with a
     *                   generation chosen by the store
     */
    case class Committed(assignment: Assignment) extends WriteAssignmentResult
  }
}
