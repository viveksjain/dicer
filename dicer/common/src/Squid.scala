package com.databricks.dicer.common

import com.databricks.api.proto.dicer.common.SquidP
import com.databricks.dicer.common.Squid.ORDERING
import com.databricks.dicer.external.ResourceAddress
import java.net.URI
import java.time.Instant
import java.util.UUID

import com.databricks.caching.util.TypedClock

/**
 * Identifier for a resource incarnation to which requests will be routed, consisting of a resource
 * address, creation time, and UUID. Collectively, these fields represent the Slicelet incarnation
 * uniQUe ID (SQUID). See accessor documentation to understand how these fields are used and why
 * they are important.
 *
 * @param resourceAddress Address of the Slicelet that is used to route requests to the Slicelet.
 *
 * @param creationTimeMillis Creation time for the SQUID in milliseconds since the Unix epoch. If
 *                           the Assigner thinks that two Slicelet incarnations with the same
 *                           resource address are healthy at the same time (both have recent
 *                           heartbeats), the resource incarnation with the more recent creation
 *                           time will be preferred in the generated assignment. Note that an
 *                           artificially advanced creation time (e.g., due to clock skew) will
 *                           cause trouble but only transiently: after the offending Slicelet stops,
 *                           it will take a few tens of seconds for the Assigner to decide it's dead
 *                           and to exclude it from the assignment.
 *
 *                           We use a millisecond precision representation instead of [[Instant]]
 *                           because that is the precision of the proto representation, and we need
 *                           to ensure that SQUIDs can round-trip.
 *
 * @param resourceUuid    Globally unique ID for the incarnation of the Slicelet. This is typically
 *                        the UUID generated by Kubernetes to identify an "occurrence" of a pod, and
 *                        to distinguish it from other historical instances of the pod, but in tests
 *                        or when Kubernetes introspection is set up incorrectly, a random UUID may
 *                        be used instead. The consequence of using a random UUID is that health
 *                        signals from the Kubernetes Watch API cannot be correlated with the
 *                        Slicelet incarnation, and the Assigner will rely exclusively on exit
 *                        notice signals sent directly from the Slicelet.
 *
 *                        When determining whether a request is affinitized to the current Slicelet,
 *                        the UUID is used only when assignment consistency is enabled. Otherwise,
 *                        any assignment to the current [[resourceAddress]] is considered valid.
 */
case class Squid private (
    resourceAddress: ResourceAddress,
    creationTimeMillis: Long,
    resourceUuid: UUID)
    extends AnyRef
    with Ordered[Squid] {

  /** The creation time for the SQUID. */
  def creationTime: Instant = Instant.ofEpochMilli(creationTimeMillis)

  /** Converts this SQUID to its proto representation. */
  def toProto: SquidP = {
    new SquidP(
      resourceAddress = Some(resourceAddress.uri.toString),
      creationTimeMillis = Some(creationTimeMillis),
      resourceUuidLow = Some(resourceUuid.getLeastSignificantBits),
      resourceUuidHigh = Some(resourceUuid.getMostSignificantBits)
    )
  }

  override def compare(that: Squid): Int = ORDERING.compare(this, that)

  override def toString: String = s"[$resourceAddress $creationTime $resourceUuid]"
}

object Squid {
  private val ORDERING = Ordering.by { (squid: Squid) =>
    (
      squid.resourceAddress,
      squid.creationTimeMillis,
      squid.resourceUuid
    )
  }

  /**
   * Creates a [[Squid]] with the current time from `clock` as creation time, the given address,
   * and the given UUID. The reason that we take an externally constructed UUID rather than creating
   * a new random one is that the UUID matches the k8s POD_UID when it is available.
   */
  def createForNewIncarnation(
      clock: TypedClock,
      resourceAddress: ResourceAddress,
      resourceUuid: UUID): Squid = {
    Squid(
      resourceAddress,
      // Truncate to millisecond precision to ensure that the creation time can round trip.
      clock.instant().toEpochMilli,
      resourceUuid
    )
  }

  /**
   * Creates a `Squid` from the given proto if it is valid. Throws
   * [[IllegalArgumentException]] otherwise.
   */
  def fromProto(proto: SquidP): Squid = {
    // Validate the proto by trying to create a URI.
    val resourceAddress = ResourceAddress(URI.create(proto.getResourceAddress))
    Squid(
      resourceAddress,
      creationTimeMillis = proto.getCreationTimeMillis,
      resourceUuid = new UUID(proto.getResourceUuidHigh, proto.getResourceUuidLow)
    )
  }
}
