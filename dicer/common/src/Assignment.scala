package com.databricks.dicer.common

import scala.collection.{immutable, mutable}

import com.databricks.api.proto.dicer.common.SquidP
import com.databricks.caching.util.WatchValueCell
import com.databricks.dicer.external.SliceKey
import com.databricks.dicer.friend.SliceMap
import com.databricks.dicer.friend.SliceMap.GapEntry

/** Consistency mode for assignment checks. */
sealed trait AssignmentConsistencyMode

object AssignmentConsistencyMode {

  /**
   * Strong mode in which Dicer guarantees that at most one Slicelet will believe it is assigned to
   * a given key at any given moment.
   */
  case object Strong extends AssignmentConsistencyMode

  /**
   * Affinity mode in which it is unlikely multiple Slicelets will simultaneously believe they are
   * assigned to given key, but where there is no strong guarantee.
   */
  case object Affinity extends AssignmentConsistencyMode
}

/**
 * REQUIRES:
 *  - `generation` is not empty.
 *  - For assignments in the "loose" incarnation, `consistencyMode` must not be `Strong`.
 *
 * Represents the assignment of Slices to resource incarnations. In contrast to [[Assignment]], each
 * Slice might have multiple assigned resources (replicas). See <internal link> for more
 * information about the structure of assignments, and <internal link>
 * for more information about the replicas.
 *
 *       Generation = 96
 *       ["" .. Fili):24 => {Pod0}
 *       [Fili .. Nori):45 => {Pod0, Pod1}
 *       [Nori .. Inf):67 => {Pod0, Pod1, Pod2}
 *
 * @param isFrozen        Whether the assignment is "frozen". When an assignment is frozen, the
 *                        Assigner's `AssignmentGenerator` will not update the assignment.
 *                        Assignments can be frozen and unfrozen via the control surface in the test
 *                        environment, and ultimately we plan to support control via a production
 *                        API as well.
 * @param consistencyMode Consistency mode to use for assignment lookups. See
 *                        [[AssignmentConsistencyMode]] for details.
 * @param generation      The generation of this assignment. Assignments have monotonically
 *                        increasing (but not necessarily sequential) values as generated by the
 *                        Assigner.
 * @param sliceMap        Map from [[Slice]]s to the incarnations of their assigned resources.
 *                        Covers the full key space.
 */
case class Assignment(
    isFrozen: Boolean,
    consistencyMode: AssignmentConsistencyMode,
    generation: Generation,
    sliceMap: SliceMap[SliceAssignment]) {

  require(generation != Generation.EMPTY, "Assignment must have non-empty generation.")
  require(
    consistencyMode != AssignmentConsistencyMode.Strong
    || generation.incarnation.isNonLoose,
    "Consistent assignment cannot be in the loose incarnation."
  )

  for (sliceAssignment: SliceAssignment <- sliceMap.entries) {
    sliceAssignment.checkAssignmentGeneration(generation)
  }

  /** Returns slice assignments in slice order. */
  def sliceAssignments: immutable.Vector[SliceAssignment] = {
    sliceMap.entries
  }

  /**
   * REQUIRES: `diffGeneration` is less than or equal to `generation`
   *
   * Creates a diff including only Slices that have changed since `diffGeneration`. The diff is full
   * (i.e., contains all Slice assignments) in several cases:
   *
   *  - When `diffGeneration` is in a different incarnation from the assignment generation. We must
   *    assume divergent histories across incarnations since incarnations are bumped only due to
   *    disasters or breaking changes to the storage layer.
   *  - When the assignment generation is in the loose incarnation (see discussion at
   *    [[Incarnation]] of why diffs are not viable).
   *
   * See [[Assignment.fromDiff()]] for a worked example.
   */
  def toDiff(diffGeneration: Generation): DiffAssignment = {
    require(
      diffGeneration <= generation, {
        s"Diff generation $diffGeneration must be less than or equal " +
        s"to assignment generation $generation"
      }
    )
    val fullAssignmentRequired = diffGeneration.incarnation != generation.incarnation ||
      generation.incarnation.isLoose
    val diffSliceMap: DiffAssignmentSliceMap =
      if (fullAssignmentRequired) {
        DiffAssignmentSliceMap.Full(sliceMap)
      } else {
        // Filter Slice assignments with generations greater than diff generation.
        val diffSliceAssignments: Seq[SliceAssignment] =
          sliceMap.entries.filter { sliceAssignment: SliceAssignment =>
            sliceAssignment.generation > diffGeneration
          }
        DiffAssignmentSliceMap.Partial(
          diffGeneration,
          SliceMap.createFromOrderedDisjointEntries(
            diffSliceAssignments,
            SliceMapHelper.SLICE_ASSIGNMENT_ACCESSOR
          )
        )
      }
    DiffAssignment(isFrozen, consistencyMode, generation, diffSliceMap)
  }

  /**
   * Returns whether the given `key` is assigned to the given `resource`. See the discussion of
   * [[AssignmentConsistencyMode]] implications at [[SubsliceAnnotationsMap.apply()]].
   */
  def isAssignedKey(key: SliceKey, resource: Squid): Boolean = {
    val sliceAssignment: SliceAssignment = sliceMap.lookUp(key)
    isResourceAssigned(sliceAssignment.resources, resource)
  }

  /**
   * Returns a Vector of [[SliceAssignment]] for the assigned [[Slice]]s on `resource`.
   * See the discussion of [[AssignmentConsistencyMode]] implications at
   * [[SubsliceAnnotationsMap.apply]].
   */
  def getAssignedSliceAssignments(resource: Squid): Vector[SliceAssignment] = {
    sliceMap.entries.filter { sliceAssignment: SliceAssignment =>
      isResourceAssigned(sliceAssignment.resources, resource)
    }
  }

  /**
   * Returns set containing all keys assigned to the given `resource`. See the discussion of
   * [[AssignmentConsistencyMode]] implications at [[SubsliceAnnotationsMap.apply()]].
   *
   * In contrast with [[getSlicesAndPredictedLoadForResource()]], the result has coalesced
   * adjacent assigned slices (see discussion at [[SliceSetImpl]]).
   */
  def getSliceSetForResource(resource: Squid): SliceSetImpl = {
    val builder = SliceSetImpl.newBuilder
    for (sliceAssignment: SliceAssignment <- sliceMap.entries) {
      if (isResourceAssigned(sliceAssignment.resources, resource)) {
        builder.add(sliceAssignment.slice)
      }
    }
    builder.build()
  }

  /** All resources that are assigned to some slice. */
  lazy val assignedResources: Set[Squid] = {
    sliceMap.entries.flatMap { sliceAssignment: SliceAssignment =>
      sliceAssignment.resources
    }.toSet
  }

  /**
   * Determines whether `lookupResource` is considered equivalent to `assignedResource` given the
   * current assignment's [[consistencyMode]]. See the discussion of [[AssignmentConsistencyMode]]
   * implications at [[SubsliceAnnotationsMap.apply()]].
   */
  def isResourceAssignmentCompatible(assignedResource: Squid, lookupResource: Squid): Boolean = {
    consistencyMode match {
      case AssignmentConsistencyMode.Affinity =>
        // In Affinity mode, only the address is considered. One of the benefits of Affinity mode is
        // that resource restarts do not invalidate assignments, making the availability of the
        // Assigner less critical to the availability of the sharded service. If we were to require
        // an exact SQUID match, that benefit would be lost.
        assignedResource.resourceAddress == lookupResource.resourceAddress
      case AssignmentConsistencyMode.Strong =>
        // In Strong mode, the SQUID must exactly match so that we don't assume that multiple
        // incarnations of a Slicelet, which may potentially be active at the same time, are both
        // assigned to the same Slices.
        assignedResource == lookupResource
    }
  }

  override def toString: String = {
    val builder = mutable.StringBuilder.newBuilder
    AssignmentFormatter.appendAssignmentToStringBuilder(
      this,
      builder,
      maxResources = 16,
      maxSlices = 32,
      loadPerResourceOpt = None,
      loadPerSliceOverrideOpt = None,
      topKeysOpt = None,
      squidFilterOpt = None
    )
    builder.toString()
  }

  /**
   * Returns whether a `lookupResource` is considered to be assigned given a set of currently
   * assigned resource incarnations and the current assignment's [[consistencyMode]]. See the
   * discussion of [[AssignmentConsistencyMode]] implications at [[SubsliceAnnotationsMap.apply()]].
   */
  def isResourceAssigned(assignedResources: Iterable[Squid], lookupResource: Squid): Boolean = {
    assignedResources.exists { assignedResource: Squid =>
      isResourceAssignmentCompatible(assignedResource, lookupResource)
    }
  }
}

object Assignment {
  type AssignmentValueCell = WatchValueCell[Assignment]
  type AssignmentValueCellConsumer = WatchValueCell.Consumer[Assignment]

  /**
   * Creates an [[Assignment]] given a potentially partial `diffAssignment` and an
   * optional known assignment to fill in gaps in the diff. Consider for example the following
   * inputs and expected output of this function, where the known assignment has generation 47, and
   * the proto contains diffs between generation 42 and 50 (there are gaps for Slices with
   * generations less than 42):
   *
   * knownAssignment @47:  | pod0 @42 | pod1 @47 | pod2 @42 | pod3 @30 | {pod3, pod4} @42     |
   * proto @50, diff @42:  | gap      | pod1 @47 | {pod2, pod3} @50    | pod3 @50 | pod4 @50  |
   * result @50:           | pod0 @42 | pod1 @47 | {pod2, pod3} @50    | pod3 @50 | pod4 @50  |
   *
   * Returns either the full assignment or a reason the diff should not be used.
   *
   * @throws NotImplementedError TODO(<internal bug>) support Consistency mode
   */
  @SuppressWarnings(Array("NonLocalReturn", "reason: TODO(<internal bug>): fix and remove suppression"))
  @throws[NotImplementedError]
  def fromDiff(
      knownAssignmentOpt: Option[Assignment],
      diffAssignment: DiffAssignment): Either[Assignment, DiffUnused.DiffUnused] = {
    if (diffAssignment.consistencyMode != AssignmentConsistencyMode.Affinity) {
      throw new NotImplementedError("TODO(<internal bug>): Only Affinity is currently supported")
    }
    knownAssignmentOpt match {
      case Some(knownAssignment: Assignment) =>
        if (knownAssignment.generation > diffAssignment.generation) {
          // Known assignment fresher than the diff assignment, nothing to learn here!
          return Right(DiffUnused.TOO_STALE_DIFF)
        } else if (knownAssignment.generation == diffAssignment.generation) {
          // Diff assignment is already known. Also nothing to learn.
          return Right(DiffUnused.DIFF_MATCHES_KNOWN)
        }

        diffAssignment.sliceMap match {
          case DiffAssignmentSliceMap.Partial(
              diffGeneration: Generation,
              sliceMap: SliceMap[GapEntry[SliceAssignment]]
              ) =>
            if (knownAssignment.generation < diffGeneration) {
              // Don't have enough information to decode the assignment.
              return Right(DiffUnused.TOO_STALE_KNOWN)
            }
            // Intersect the diff map (which may includes gaps) with the known assignment.
            type GapEntry = SliceMap.GapEntry[SliceAssignment]
            type IntersectionEntry =
              SliceMap.IntersectionEntry[SliceAssignment, GapEntry]
            val intersected: SliceMap[IntersectionEntry] =
              SliceMap.intersectSlices(knownAssignment.sliceMap, sliceMap)
            val newSliceAssignments = immutable.Vector.newBuilder[SliceAssignment]
            for (entry: IntersectionEntry <- intersected.entries) {
              val existingSliceAssignment: SliceAssignment = entry.leftEntry
              entry.rightEntry match {
                case GapEntry.Some(newSliceAssignment: SliceAssignment) =>
                  if (existingSliceAssignment.generation > newSliceAssignment.generation) {
                    return Right(DiffUnused.INCONSISTENCY)
                  }
                  // A new Slice assignment may overwrite multiple existing Slice assignments in the
                  // case of a merge-like modification, only emit for the last intersecting entry.
                  if (newSliceAssignment.slice.highExclusive == entry.slice.highExclusive) {
                    newSliceAssignments += newSliceAssignment
                  }
                case GapEntry.Gap(_) =>
                  // The Slice is not overwritten in the new assignment.
                  newSliceAssignments += existingSliceAssignment
              }
            }
            Left(
              Assignment(
                diffAssignment.isFrozen,
                diffAssignment.consistencyMode,
                diffAssignment.generation,
                SliceMapHelper.ofSliceAssignments(newSliceAssignments.result())
              )
            )
          case DiffAssignmentSliceMap.Full(
              sliceMap: SliceMap[SliceAssignment]
              ) =>
            // We have a full assignment, pass it through.
            Left(
              Assignment(
                diffAssignment.isFrozen,
                diffAssignment.consistencyMode,
                diffAssignment.generation,
                sliceMap
              )
            )
        }
      case None => // No known assignment.
        diffAssignment.sliceMap match {
          case DiffAssignmentSliceMap.Partial(_, _) =>
            // Can't create an assignment from a diff when there is no known assignment.
            Right(DiffUnused.NO_KNOWN)
          case DiffAssignmentSliceMap.Full(
              sliceMap: SliceMap[SliceAssignment]
              ) =>
            Left(
              Assignment(
                diffAssignment.isFrozen,
                diffAssignment.consistencyMode,
                diffAssignment.generation,
                sliceMap
              )
            )
        }
    }
  }

  /**
   * A map tracking resource incarnations in an [[Assignment]] and the indices used to
   * identify those resources in a [[DiffAssignmentP]].
   */
  private[common] class ResourceMap private (resources: Seq[Squid]) {

    /**
     * Resolves the resource with the given `index`.
     *
     * @throws IllegalArgumentException if `index` is out of range
     */
    @throws[IllegalArgumentException]
    def resourceFromProtoIndex(index: Int): Squid = {
      require(
        index >= 0 && index < resources.size,
        s"Resource index $index out of range. Proto contains ${resources.size} resources."
      )
      resources(index)
    }
  }

  private[common] object ResourceMap {

    /**
     * Converts the given sequence of resource addresses to a resource map.
     *
     * @throws IllegalArgumentException if any element of `protos` cannot be parsed.
     */
    @throws[IllegalArgumentException]
    def fromProtos(protos: Seq[SquidP]): ResourceMap =
      new ResourceMap(protos.map { proto: SquidP =>
        Squid.fromProto(proto)
      })
  }

  /**
   * Helper assigning indices to resource incarnations when serializing an
   * [[Assignment]] to [[DiffAssignmentP]].
   */
  private[common] class ResourceProtoBuilder {

    /**
     * Resource incarnations identified so far, to be identified in [[DiffAssignmentP]] by their
     * index in this vector.
     */
    private val resources = new mutable.ArrayBuffer[Squid]

    /** Map from resource to index in [[resources]]. */
    private val resourceIndexMap = new mutable.HashMap[Squid, Int]

    /**
     * Returns the index for the given resource, choosing an index if one has not yet been assigned.
     */
    def getIndex(resource: Squid): Int = {
      resourceIndexMap.get(resource) match {
        case Some(index) => index // given resource is already known
        case None =>
          val index = resources.size
          resources += resource
          resourceIndexMap.put(resource, index)
          index
      }
    }

    /** Serializes the resources identified by this builder as protos. */
    def toProtos: Seq[SquidP] =
      resources.map { resource: Squid =>
        resource.toProto
      }.toSeq
  }

  /**
   * Enumeration of reasons a diff passed to [[fromDiff()]] may be unused or unusable. These cases
   * are conveyed as an explicit enumeration rather than throwing exceptions because the
   * requirements for inputs to [[fromDiff()]] are too complex to be reasonably checked by all
   * callers and are (with the exception of `INCONSISTENCY`) expected outcomes of the assignment
   * sync protocol.
   */
  object DiffUnused extends Enumeration {
    type DiffUnused = Value

    /**
     * An inconsistency was detected between the diff and known assignments, e.g., the known
     * assignment has Slices with higher generations than a supposedly fresher diff assignment.
     */
    val INCONSISTENCY: Value = Value

    /**
     * The known assignment has a greater generation than the diff (making it uninteresting).
     */
    val TOO_STALE_DIFF: Value = Value

    /** The known assignment has the same generation as the diff (making it uninteresting). */
    val DIFF_MATCHES_KNOWN: Value = Value

    /** A partial diff was supplied but there is no known assignment. */
    val NO_KNOWN: Value = Value

    /**
     * A partial diff was supplied with a diff generation that is greater than that of the known
     * assignment (i.e. the diff spanned a window of history that started strictly ahead of the
     * known assignment, leaving a gap and making the diff unable to be applied to the known
     * assignment).
     */
    val TOO_STALE_KNOWN: Value = Value
  }
}
