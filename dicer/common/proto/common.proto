syntax = "proto2";

package dicer;

import "dicer/friend/proto/friend.proto";
import "scalapb.proto";

option java_package = "com.databricks.api.proto.dicer.common";
option java_generate_equals_and_hash = true;
option (scalapb.options) = {
  flat_package: true,
};

// The generation used for versioning assignments/redirects - see specs on Generation for more
// details.
// Note: If we change this proto, we need to change the corresponding proto in the logs package.
// `LoggedGenerationP` is present in `proto/logs/caching/caching_team_log.proto`.
message GenerationP {
  // The incarnation number (most significant bits) of this generation.
  optional int64 incarnation = 1;

  // The generation number (least significant bits) of this generation.
  optional int64 number = 2;
}

// Incremental representation of an `Assignment` capturing all Slice assignments that have changed
// between `diff_generation` (exclusive) until `generation` (inclusive). When `diff_generation` is
// empty, the message contains a full assignment.
//
// WARNING: The implementation in `DiffAssignmentP` must continue to match the implementation in
// `proto/logs/caching/caching_team_log.proto` `LoggedDiffAssignmentP` for automatic conversion
// between the two.
// If you change the implementation in `DiffAssignmentP` (and its nested members), you must also 
// change the implementation in `proto/logs/caching/caching_team_log.proto` `LoggedDiffAssignmentP`.
message DiffAssignmentP {
  // The generation of the assignment.
  optional GenerationP generation = 1;

  // Ordered sequence of Slice assignments in the assignment with Slice generations greater than
  // `diff_generation`. When `diff_generation` is empty or is a generation in a loose incarnation,
  // the message contains a full assignment.
  repeated SliceAssignmentP slice_assignments = 2;

  // The resource incarnations to which `slice_assignments` or `squid_leases` refer.
  repeated SquidP resources = 3;

  // OPTIONAL (absent means "not frozen"): whether the assignment is "frozen". When an assignment is
  // frozen, the Assigner's `AssignmentGenerator` will not update the assignment. Assignments can be
  // frozen and unfrozen via the control surface in the test environment, and ultimately we plan to
  // support control via a production API as well.
  optional bool is_frozen = 4;

  // OPTIONAL (absent interpreted as `Generation.EMPTY`). See `slice_assignments`.
  optional GenerationP diff_generation = 5;

  // SQUID leases, populated only for consistent assignments. Contains an entry for all SQUID leases
  // in the "active" or "recalled" state. Also includes all leases that entered the "revoked" state
  // no earlier than the current GC threshold (see `squid_lease_gc_threshold_generation_number`).
  repeated SquidLeaseP squid_leases = 6;

  // The GC threshold for `squid_leases`. The earliest assignment generation for which "revoked"
  // leases are retained has incarnation `generation.incarnation` and generation number
  // `squid_lease_gc_threshold_generation_number`.
  optional int64 squid_lease_gc_threshold_generation_number = 7;

  // OPTIONAL (absent interpreted as "inconsistent"): whether consistent assignment is enabled.
  // When true, Slicelets must verify strict ownership to satisfy
  // `SliceletHandle.isContinuouslyAssigned` checks. Must only be set for assignments in durable or
  // "non-loose" incarnations (in which divergent assignment histories are not possible).
  optional bool is_consistent = 8;

  // Represents an assignment of a Slice to one or more resources, e.g.,
  // ["Ax" ... "Bg") -> ("Pod2", "Pod3").
  message SliceAssignmentP {
    optional dicer.friend.SliceP slice = 1;

    // The Slice assignment is guaranteed to have been unchanged between this generation and the
    // generation of the containing assignment. See `SliceAssignment.generation` for important
    // details.
    optional GenerationP generation = 2;

    // References to the resource incarnations to which this Slice is assigned. Values are indices
    // for the `DiffAssignmentP.resources` array. The Slice might be assigned to multiple resources.
    // See <internal link> for more information.
    repeated int32 resource_indices = 3;

    // A list of subslice annotations for a resource. These annotations can indicate that state for
    // the subslice can be fetched from another resource, and/or enable finer-grained handling of
    // `isAssignedContinuously`. E.g. if a slice is split or merged but still assigned to the same
    // resource, `SliceAssignmentP.generation` will be updated for each slice but
    // `subslice_annotations` can still track the old `generation_number`.
    // Invariants:
    // - `generation_number` must be less than or equal to `SliceAssignmentP.generation.number`.
    //   The incarnation number is the same by construction, since if incarnation changes we cannot
    //   make any guarantees about continuous assignment.
    // - `subslice` must be contained in `slice`. But the combined `subslice`s do not need to cover
    //   the entire `slice`.
    // - For a particular `resource_id`, each `subslice` must be disjoint.
    // - For a particular `resource_id`, the `subslice`s are ordered.
    repeated SubsliceAnnotationP subslice_annotations = 4;

    // OPTIONAL (absent interpreted as "unknown"): see `SliceAssignment.primaryRateLoadOpt` for
    // details.
    optional double primary_rate_load_opt = 5;
  }

  // Represents information about the subslices that are continuously assigned to the same resource
  // across Slice generations. Optionally includes a `state_transfer` message to indicate that the
  // subslice state can be fetched from another resource.
  message SubsliceAnnotationP {
    // An index into the `resources` array for which this annotation applies.
    // The referenced resource must also be in the parent `SliceAssignmentP.resource_indices` array.
    optional int32 resource_id = 1;

    // A subslice of the parent Slice assignment.
    optional dicer.friend.SliceP subslice = 2;

    // The generation number starting from which the subslice was continuously assigned to
    // `resource_id`. Assuming that the parent `DiffAssignmentP.generation` is
    // `assignment_generation`, the Slicelet can assume that it has been continuously assigned in
    // the closed range:
    //
    //     `[generation_number, assignment_generation.generation_number]`
    //
    // If an ownership_transfer exists (we have not yet added a field for it), the subslice is not
    // strictly owned by the resource until the previous owner, identified by
    // `ownership_transfer.from_resource_id`, has surrendered the subslice, or until the SQUID for
    // the previous owner has been revoked. The Assigner will remove the ownership transfer when
    // either of these conditions is met. As an optimization, `resource_id` may establish ownership
    // of the subslice as soon as it learns about the surrender by
    // `ownership_transfer.from_resource_id`, without waiting for the Assigner to update the
    // assignment.
    //
    // Coalescing
    // ----------
    // Over time, it may be desirable to coalesce contiguous, adjacent subslices with similar
    // generation values. This would avoid a hypothetical problem where a large number of prior
    // subslice boundaries for a given Slice:resource assignment are retained. Such an optimization
    // can only be applied if there is no `state_transfer` or `ownership_transfer` present
    // however, since otherwise Slicelets will be unable to identify the slicelet they are getting
    // states from, or the specific transitional subslices they are surrendering.
    optional int64 generation_number = 3;

    // OPTIONAL: when present, indicates that the state for this subslice can be fetched from
    // `state_transfer.from_resource_id`.
    optional TransferP state_transfer = 4;
  }

  // A request to transfer a subslice assignment from one resource to another. "Transfer" can
  // refer to state (for state transfer) and/or strict ownership (for consistent assignments).
  //
  // For consistent assignments, a transfer completes and the
  // `SubsliceAnnotationP.ownership_transfer` is removed when either:
  //  - The "from" resource (identified by `TransferP.from_resource_id`) surrenders the
  //    subslice assignment.
  //  - The "from" resource has its SQUID lease revoked by the Assigner.
  //
  // For inconsistent assignments, transfers may complete when either:
  //  - The target of the transfer (identified by `SubsliceAnnotationP.resource_id`) signals that
  //    state has been transferred.
  //  - The Assigner arbitrarily decides the transfer is complete (e.g., if the Assigner decides
  //    that it is taking too long).
  message TransferP {
    // Number that uniquely identifies the transfer within the transfer generation (from
    // `SubsliceAnnotationP.generation_number`).
    optional int32 id = 1;

    // Reference to the resource from which the subslice assignment is transitioning. Must reference
    // a different resource than `SubsliceAnnotationP.resource_id`.
    optional int32 from_resource_id = 2;

    // OPTIONAL: The generation number from which `from_resource_id` had continuous ownership of the
    // current subslice. For state transfer with consistent assignments, this is used to ensure a
    // linearizable history of the state - see
    // <internal link>.8vy8b2elpow6 for more details. This field
    // is not currently populated for state transfer, as it is not required with inconsistent
    // assignments.
    //
    // For an ownership transition, this is included in the "to" resource's relinquish RPC to ensure
    // that the "from" resource does not unnecessarily relinquish ownership based on a stale RPC.
    // Prior to relinquishing ownership, the "from" resource can still satisfy
    // `isAssignedContinuously` checks for the subslice.
    // NOTE: at present, this is not a helpful field, since the Slicelet is designed to immediately
    // surrender when it observes such a transition. Longer term, we may benefit from the ability
    // to defer surrender until, e.g., the LinkStore client library observes that outstanding write
    // handles have been closed.
    optional int64 continuous_ownership_generation_number = 3;
  }

  message SquidLeaseP {
    // An index into the `resources` array referencing the SQUID to which this lease applies.
    optional int32 resource_id = 1;

    // Possible lease states. If no field is present, it indicates that the lease has been
    // permanently revoked.
    oneof lease_state {
      // The lease is active. The SQUID lease holder may assume that if the lease is subsequently
      // recalled, the lease can not be permanently revoked until at least the given number of
      // seconds have elapsed or the lease holder acknowledges the recall, whichever comes first.
      //
      // For a given SQUID, the grace period will never change.
      int32 lease_active_grace_period_seconds = 2;

      // The lease has been recalled. The value indicates the minimum number of seconds that must
      // elapse after this assignment is committed before the lease can be permanently revoked, if
      // it not revoked sooner by way of a recall acknowledgment from the SQUID lease holder. This
      // value may decrease in successive assignments, but will never increase. The value is used by
      // the assigner to determine when it is safe to permanently revoke the lease absent a recall
      // acknowledgment.
      int32 lease_recalled_grace_period_seconds = 3;
    }
  }
}

// Globally unique identifier for a Slicelet incarnation. See `com.databricks.dicer.common.Squid`
// for detailed documentation.
// Note: If we change this proto, we need to change the corresponding proto in the logs package.
// `LoggedSquidP` is present in `proto/logs/caching/caching_team_log.proto`.
message SquidP {
  // URI that is used to route requests to the Slicelet.
  optional string resource_address = 1;

  // Creation time for the SQUID.
  optional int64 creation_time_millis = 2;

  // Most significant bits of the resource UUID.
  optional int64 resource_uuid_high = 3;

  // Least significant bits of the resource UUID.
  optional int64 resource_uuid_low = 4;
}

// The assignment state that is exchanged across all messages where the caller indicates either the
// assignment generation that it is aware of or the actual assignment if it believes that the remote
// side has an assignment with a lower generation number.
message SyncAssignmentStateP {
  oneof state {
    // The latest assignment generation that the sender is aware of.
    GenerationP known_generation = 1;

    // The assignment that the sender is aware of.
    DiffAssignmentP known_assignment = 2;

    // The serialized `known_assignment`. This allows the server to cache the same serialized
    // assignment for multiple clients and avoids repeated serialization at the gRPC level.
    bytes known_serialized_assignment = 3;
  }
}

// Sent by the server to inform the client of how to direct its future requests, either to a random
// address (the default) or to a specific address.
//
message RedirectP {
  // Removed fields.
  reserved 2, 3, 4;

  // OPTIONAL: URI to which the request should be redirected. If empty, the client should use the
  // default behavior which sends it to a random assigner/Slicelet.
  optional string address = 1;
}

// Request sent by the Clerk or the Slicelet (Subscriber) to watch for changing assignments.
message ClientRequestP {
  option (scalapb.message).extends = "com.databricks.rpc.RPC[ClientResponseP]";

  // Removed fields.
  reserved 7, 8, 10;

  // Identify the sharded set of resources whose assignment is being watched. This is a logical name
  // that all the involved Slicelets and Clerks need to agree on.
  optional TargetP target = 1;
  // Note: If we change this proto, we need to change the corresponding proto in the logs package.
  // `LoggedTargetP` is present in `proto/logs/caching/caching_team_log.proto`.
  message TargetP {
    // The name of the Dicer-sharded service as defined in <internal link>, e.g.,
    // "softstore-storelet".
    //
    // See `com.databricks.dicer.external.Target.name` for detailed documentation.
    optional string name = 1;

    // Types of a Target.
    enum Type {
      TYPE_UNSPECIFIED = 0;

      // A Kubernetes target is a type of Dicer target where instances are distinguished by the
      // Kubernetes cluster where they are running. A Kubernetes target is limited to a single
      // instance per cluster, and the cluster must remain stable throughout the target's lifetime.
      // This target type applied to all targets before `APP` targets were introduced, as it was
      // then assumed that a target name and cluster URI fully qualified a unique instance of a
      // Dicer-sharded service.
      //
      // See `com.databricks.dicer.external.KubernetesTarget` for detailed documentation.
      KUBERNETES = 1;

      // An App target is a type of Dicer target where instances are distinguished by a unique
      // application instance identifier (see https://go/app-identifiers).
      //
      // See `com.databricks.dicer.external.AppTarget` for detailed documentation.
      APP = 2;
    }

    // The type of the Dicer-sharded service. If the field is not set, the behavior is equivalent to
    // as if it is set to TYPE_UNSPECIFIED.
    optional Type target_type = 3;

    // OPTIONAL: The URI of the Kubernetes cluster where the Dicer-sharded service is running, e.g.,
    // "kubernetes-cluster:test-env/cloud1/public/region8/clustertype2/01". This field must be set for KUBERNETES
    // targets when connecting to Dicer deployments running in remote clusters (e.g. clients running
    // in the dataplane connecting to Dicer running in the region's GENERAL clusters). For targets
    // running in the same cluster as the Dicer service, this is optional, and if not supplied, is
    // assumed by the Assigner to be in the local cluster.
    //
    // See `com.databricks.dicer.external.Target.clusterOpt` for detailed documentation.
    optional string kubernetes_cluster_uri = 2;

    // OPTIONAL: The instance identifier of the Dicer-sharded service. This distinguishes the target
    // instance from other instances with the same target name. This field must be set by targets
    // with type `APP`.
    optional string instance_id = 4;
  }

  // The assignment state that the sender wants to sync with the receiver.
  optional SyncAssignmentStateP sync_assignment_state = 2;

  // Name of the subscriber for debugging purposes.
  optional string subscriber_debug_name = 3;

  // The timeout that the client has chosen for this RPC.
  optional int64 chosen_rpc_timeout_millis = 4;

  oneof SubscriberDataP {
    // Additional fields sent by the Clerk.
    ClerkDataP clerk_fields = 5;

    // Additional fields sent by the Slicelet, e.g., convey its health/load information.
    SliceletDataP slicelet_fields = 6;
  }

  // The version of the code that the client is running. The meaning of the version number is
  // defined in dicer/common/src/Version.scala.
  optional int64 version = 9;

  optional ClientFeatureSupportP client_feature_support = 11;

  // The set of features supported by the client. The server can use this information to determine
  // what it can include in its response. Fields in this message should eventually be graduated
  // once they are fully rolled out.
  message ClientFeatureSupportP {
    // Whether the client supports parsing serialized assignments. If true, the server may
    // return serialized assignment in response to this request.
    optional bool supports_serialized_assignment = 1;
  }

  // Next unused field number: 12

  // Clerk-specific information sent by the Clerk.
  message ClerkDataP {
  }

  // Slicelet-specific information sent by the Slicelet.
  message SliceletDataP {
    // TODO(<internal bug>): remove this field
    // DEPRECATED: contained in `squid.incarnation_uuid_low` and `squid.incarnation_uuid_high`.
    optional string nonce = 1;

    // TODO(<internal bug>): remove this field
    // DEPRECATED: contained in `squid.resource_address`.
    optional string uri = 2;

    // Indicates the health status of the Slicelet.
    optional State state = 3;

    // Various states of the Slicelet.
    enum State {
      UNKNOWN = 0;
      NOT_READY = 1;
      RUNNING = 2;
      TERMINATING = 3;
    }

    // Globally unique identifier for the Slicelet incarnation for the current Slicelet.
    optional SquidP squid = 4;

    // Aggregate load measurements over some time window on the Slice replica represented by
    // (`squid`, `SliceLoadP.slice`).
    message SliceLoadP {
      // The primary rate load (e.g., time-weighted mean of QPS). "Primary" to distinguish from the
      // (as yet unsupported) other load measurements. "Rate" to distinguish from (as yet
      // unsupported) gauge measurements (e.g., memory usage) which must be provided through
      // synthesized incremental rate updates (e.g., incrementing memory usage by 1MiB every 1s to
      // represent a 1MiB memory footprint). This includes the load from `top_keys`.
      optional double primary_rate_load = 1;

      // The time window over which the load measurements are aggregated, in seconds since the
      // Unix epoch. When a Slicelet is assigned a new Slice, it begins to aggregate load
      // measurements over an ever-growing window that eventually encompasses the entire lifetime of
      // its assignment. The Assigner will ignore load measurements until they cover a sufficiently
      // long window (~1 minute), and will ignore load measurements that are too old (where the
      // high-exclusive bound is ~5 minutes or more in the past).
      optional int64 window_low_inclusive_seconds = 2;
      optional int64 window_high_exclusive_seconds = 3;

      // The range of keys to which the load measurement applies.
      optional dicer.friend.SliceP slice = 4;

      // OPTIONAL: an arbitrary number of keys within this Slice, that have the highest estimated
      // load.
      repeated KeyLoadP top_keys = 5;

      // The number of replicas of `slice`, known by `squid` at the time when this SliceLoad was
      // generated. This information is reported in SliceLoad to the assigner so that the assigner
      // can use it to estimate the total load on `slice` (see
      // `com.databricks.dicer.assigner.LoadWatcher` for more information).
      optional int32 num_replicas = 6;
    }

    // Reported load measurements for a particular key.
    message KeyLoadP {
      // The key to which the load measurement applies.
      optional bytes slice_key = 1;

      // Estimated primary rate load for this particular key. Note this should be an underestimate,
      // i.e. the real time-weighted load is greater than or equal to this value.
      optional double underestimated_primary_rate_load = 2;
    }

    // The load on the Slicelet attributed to each assigned Slice.
    repeated SliceLoadP attributed_loads = 5;

    // The unattributed load on the Slicelet, i.e., the load that is not attributed to any assigned
    // Slice.
    optional SliceLoadP unattributed_load = 6;

    // Kubernetes namespace for the Slicelet host.
    optional string kubernetes_namespace = 7;

    // OPTIONAL: the latest assignment generation at which the Slicelet knows that `squid` had never
    // been recalled. This field is ignored for inconsistent assignments. When assignment
    // consistency is enabled for a target, the Slicelet sets the field to request activation of its
    // SQUID lease.
    //  - If this field is not set, it means that the heartbeat is for a new Slicelet incarnation
    //    and the Slicelet needs to receive the latest assignment before a SQUID lease can be
    //    activated. The Assigner does not yet incorporate the Slicelet into the assignment, and
    //    instead waits until it receives a heartbeat from the Slicelet with this field populated.
    //    Once the Slicelet has observed the latest assignment, it sends another heartbeat with this
    //    field populated because it knows that the SQUID cannot have been recalled before
    //    activation is requested.
    //  - When supplied, the Assigner will:
    //      - Do nothing if the SQUID lease is already known to be active, recalled, or revoked.
    //      - If it's a new SQUID from the Assigner's perspective and the Assigner can prove that
    //        the SQUID has not been recalled since `never_recalled_generation`, the Assigner will
    //        activate the lease by adding it to the assignment.
    //      - If the Assigner cannot prove that the SQUID has not been recalled or revoked since
    //        `never_recalled_generation` (if `never_recalled_generation` is earlier than the GC
    //        threshold for lease recall and revocation), the Assigner immediately moves the lease
    //        to the revoked state rather than activating a lease. This guarantees that SQUID leases
    //        are never resurrected.
    optional GenerationP never_recalled_generation = 8;

    // SQUIDs previously chosen by the Slicelet that it has released. By including a SQUID in this
    // collection, the Slicelet indicates that it is no longer satisfying any ownership checks using
    // the SQUID. The Slicelet includes a SQUID in this list when it notices that the SQUID is
    // marked "recalled" in the assignment. The Slicelet may stop including a SQUID in this list
    // when the assignment indicates that the SQUID is "revoked" or when the SQUID no longer appears
    // in the assignment.
    repeated SquidP released_squids = 9;

    // Indicates to the Assigner that the resource from which a subslice assignment is transitioning
    // is being surrendered by the current owner.
    //
    // A Slicelet that has surrendered a Slice assignment (or that is aware of that surrender
    // because the the original resource surrendered to it) must continue sending this surrender
    // notice until it observes that the transition has been removed from the assignment.
    repeated SurrenderP surrenders = 10;
    message SurrenderP {
      // See `SubsliceAnnotationP.generation_number`.
      optional GenerationP generation = 1;

      // See `TransferP.id`.
      optional int32 transfer_id = 2;
    }

    // Approximate key cardinality measurement.
    message KeyCardinalityP {
      // The time window over which the cardinality measurements are aggregated, in seconds since
      // the Unix epoch.
      optional int64 window_low_inclusive_seconds = 1;
      optional int64 window_high_exclusive_seconds = 2;

      // The HyperLogLog sketch (HLL-4) representing the cardinality estimate.
      optional bytes hll4_sketch = 3;
    }

    // Global cardinality measurement for all keys assigned to this Slicelet.
    optional KeyCardinalityP attributed_key_cardinality = 11;

    // Global cardinality measurement for all keys not assigned to this Slicelet.
    optional KeyCardinalityP unattributed_key_cardinality = 12;
  }
}

// The response for a Watch request - contains state to sync the assignment.
message ClientResponseP {

  // Removed fields.
  reserved 4;

  // The assignment state that the sender (replier of the RPC) wants to sync with the receiver (the
  // original requestor of the RPC).
  optional SyncAssignmentStateP sync_assignment_state = 1;

  // The timeout that the server suggests for the next RPC.
  optional int64 suggested_rpc_timeout_millis = 2;

  // OPTIONAL: if present, indicates that the request should be redirected to the given address.
  optional RedirectP redirect = 3;
}

// The service that the Clerk and the Slicelets connect to for getting assignments,
// reporting health, etc.
service AssignmentService {
  // The Clerk/Slicelet watch RPC to the Assigner.
  rpc Watch(ClientRequestP) returns (ClientResponseP) {}
}

// -Protos and service definitions for the SquidLeaseRecallService:

// Request type for a `SquidLeaseRecallService.GetRecallStatus` RPC
message GetRecallStatusRequestP {
  option (scalapb.message).extends = "com.databricks.rpc.RPC[GetRecallStatusResponseP]";

  // The name of the Dicer target to which the Slicelet belongs.
  optional string target_name = 1;

  // The SQUID for which lease status is requested.
  optional SquidP squid = 2;

  // The latest assignment generation at which the Slicelet knows its SQUID lease had never been
  // recalled. This is generally the generation of the latest assignment in which the SQUID lease
  // was marked active, but the Slicelet bootstraps the value by observing the latest assignment
  // _before_ it requests activation of the lease. Because the SQUID is single-use, the Assigner
  // cannot have recalled the lease before the Slicelet requests activation of the lease!
  optional GenerationP never_recalled_generation = 3;
}

// Response type for a `SquidLeaseRecallService.GetRecallStatus` RPC.
message GetRecallStatusResponseP {
  // is_valid = true
  // ---------------
  // When true, it means that there was no recall of the lease recorded at the time of the request,
  // and the lease service has knowledge of all recalls committed after `never_recalled_generation`.
  // The Slicelet can assume that its SQUID lease is valid while the grace period (from
  // `SquidLeaseP.lease_active_grace_period_seconds`) has not yet elapsed.
  //
  // The Slicelet must start a timer before calling the `GetRecallStatusRequestP` RPC. When it
  // receives a `NOT_RECALLED` response, it can assume that its lease remains valid until the
  // timer reaches `lease_active_grace_period_seconds / (1 + clock_rate_skew)`, or until it
  // voluntarily releases the lease (see below).
  //
  // is_valid = false
  // ----------------
  // When false (or unset), the Slicelet _must_ immediately stop satisfying any ownership checks for
  // the SQUID.
  //
  // The Slicelet _should_ repeatedly acknowledge the recall to the Assigner (by including the
  // corresponding SQUID in `SliceletDataP.released_squids` in its heartbeats) until it observes
  // that the lease has been successfully revoked. Acknowledging the recall allows the Assigner to
  // more quickly reassign Slices assigned to the current SQUID.
  optional bool is_valid = 1;

  // The worst-case ratio by which the Slicelet's ticker clock may be skewed relative to the "ideal"
  // clock. For example, if the skew is 5%, it means that the Slicelet's ticker clock may run faster
  // than the ideal clock by up to 5%. The Slicelet can only be certain that _at most_ 21 ideal
  // seconds have elapsed when its clock has measured _at most_ 20 elapsed seconds
  // (21 seconds / (1 + 0.05)).
  //
  // The clock rate skew configuration is relatively static, but we include it in the response so
  // that it is possible for the skew to be adjusted by Dicer backend services if necessary.
  optional double clock_rate_skew = 2;
}

// The service used by Slicelet to determine whether their SQUID leases have been recalled.
service SquidLeaseRecallService {

  // Checks whether a SQUID has been recalled and how long the Slicelet may assume its SQUID will
  // remain valid. (After a SQUID is recalled, it is guaranteed to remain valid for some interval of
  // time.)
  rpc GetRecallStatus(GetRecallStatusRequestP) returns (GetRecallStatusResponseP) {}
}
