syntax = "proto2";

package dicer.test;

import "dicer/common/proto/common.proto";
import "dicer/friend/proto/friend.proto";
import "scalapb.proto";

option java_package = "com.databricks.dicer.common";;
option java_generate_equals_and_hash = true;
option java_outer_classname = "TestDriverProto";
option java_multiple_files = true;
option (scalapb.options) = {
  package_name: "com.databricks.dicer.common",
  flat_package: true,
};

// A gRPC service that is exposed by the Rust test driver, which runs as a subprocess and is called
// into by the main Scala test process to create and interact with Rust components.
//
// This allows the same test suites written in Scala to be run against both the Scala and Rust
// implementations of Dicer client library components.
service TestDriver {
  // Creates and interacts with a Rust `SliceLookup` instance.
  //
  // This is streaming-based whereas the Slicelet-related RPCs are unary, because we need to stream
  // the new generations that the `SliceLookup` learns about back to the main Scala process.
  rpc DriveSliceLookup(stream SliceLookupRequestP) returns (stream SliceLookupResponseP);

  // Creates a Rust `Slicelet` instance.
  rpc CreateSlicelet(CreateSliceletRequestP) returns (CreateSliceletResponseP);

  // Calls the `start` method on a previously created Rust `Slicelet` instance.
  //
  // If the Slicelet is started successfully, then there will be exactly one `is_started` response
  // followed by a stream of `assignment_updated` responses for each time a new assignment is
  // discovered.
  //
  // If starting the Slicelet fails, then the stream will be terminated with an error.
  rpc StartSlicelet(StartSliceletRequestP) returns (stream StartSliceletResponseP);

  // Drops a previously created Rust `Slicelet` instance.
  rpc StopSlicelet(StopSliceletRequestP) returns (StopSliceletResponseP);

  // Retrieves the watch server port of a previously created Rust `Slicelet` instance.
  rpc GetSliceletWatchServerPort(GetSliceletWatchServerPortRequestP)
      returns (GetSliceletWatchServerPortResponseP);

  // Calls the `assigned_slices` method on a previously created Rust `Slicelet` instance.
  rpc GetAssignedSlices(GetAssignedSlicesRequestP) returns (GetAssignedSlicesResponseP);

  // Calls the `get_latest_assignment_for_test` function for a previously created Rust `Slicelet`
  // instance.
  rpc GetLatestAssignment(GetLatestAssignmentRequestP) returns (GetLatestAssignmentResponseP);

  // Retrieves the SQUID of a previously created Rust `Slicelet` instance.
  rpc GetSliceletSquid(GetSliceletSquidRequestP) returns (GetSliceletSquidResponseP);

  // Creates a slice key handle using a previously created Rust `Slicelet` instance.
  rpc CreateSliceKeyHandle(CreateSliceKeyHandleRequestP) returns (CreateSliceKeyHandleResponseP);

  // Checks whether a slice key handle is continuously assigned.
  rpc GetSliceKeyHandleIsAssignedContinuously(
      GetSliceKeyHandleIsAssignedContinuouslyRequestP)
      returns (GetSliceKeyHandleIsAssignedContinuouslyResponseP);

  // Closes a previously created slice key handle.
  rpc CloseSliceKeyHandle(CloseSliceKeyHandleRequestP)
      returns (CloseSliceKeyHandleResponseP);

  // Increments load by a given value for a slice key handle.
  rpc IncrementSliceKeyHandleLoadBy(IncrementSliceKeyHandleLoadByRequestP)
      returns (IncrementSliceKeyHandleLoadByResponseP);

  // Advances the fake time by the specified duration (only works if fake time is enabled).
  rpc AdvanceTime(AdvanceTimeRequestP) returns (AdvanceTimeResponseP);

  // Creates a Rust `Clerk` instance.
  rpc CreateClerk(CreateClerkRequestP) returns (CreateClerkResponseP);

  // Drops a previously created Rust `Clerk` instance.
  rpc StopClerk(StopClerkRequestP) returns (StopClerkResponseP);

  // Calls the `ready` method on a previously created Rust `Clerk` instance.
  rpc ClerkReady(ClerkReadyRequestP) returns (ClerkReadyResponseP);

  // Calls the `get_stub_for_key` method on a previously created Rust `Clerk` instance.
  rpc ClerkGetStubForKey(ClerkGetStubForKeyRequestP) returns (ClerkGetStubForKeyResponseP);

  // Samples `get_stub_for_key` multiple times and returns a histogram of results.
  rpc ClerkSampleStubForKey(ClerkSampleStubForKeyRequestP) returns (ClerkSampleStubForKeyResponseP);

  // Creates a Rust `CrossClusterClerk` instance.
  rpc CreateCrossClusterClerk(CreateCrossClusterClerkRequestP)
      returns (CreateCrossClusterClerkResponseP);

  // Gets the debug name of a Rust `Clerk` instance.
  rpc GetClerkDebugName(GetClerkDebugNameRequestP) returns (GetClerkDebugNameResponseP);

  // Creates a `SubscriberHandler` instance.
  rpc CreateSubscriberHandler(CreateSubscriberHandlerRequestP)
      returns (CreateSubscriberHandlerResponseP);

  // Sets the assignment in the handler's watch cell.
  rpc SetSubscriberHandlerAssignment(SetSubscriberHandlerAssignmentRequestP)
      returns (SetSubscriberHandlerAssignmentResponseP);

  // Calls `handle_watch` on a previously created `SubscriberHandler` instance.
  rpc WatchSubscriberHandler(WatchSubscriberHandlerRequestP)
      returns (WatchSubscriberHandlerResponseP);

  // Cancels a previously created `SubscriberHandler` instance.
  rpc CancelSubscriberHandler(CancelSubscriberHandlerRequestP)
      returns (CancelSubscriberHandlerResponseP);
}

// A request from the Scala test process to the Rust test driver server subprocess to interact with
// a `SliceLookup`.
message SliceLookupRequestP {
  // Must be sent exactly once as the first request on the stream to initialize the `SliceLookup`
  // instance.
  //
  // The fields of this proto correspond to `SliceLookupConfig` fields.
  message InitP {
    optional string watch_address = 1;
    optional ClientRequestP.TargetP target = 2;
    optional string subscriber_debug_name = 3;
    optional ClientTypeP client_type = 4;
    optional bool watch_from_data_plane = 5;
  }

  // Instructs the test driver to call `SliceLookup::start`.
  message StartP {}

  // Instructs the test driver to retrieve the current assignment from the `SliceLookup`.
  message GetAssignmentP {}

  // Instructs the test driver to check whether the given key is assigned to the given resource in
  // the current assignment.
  message IsAssignedKeyP {
    optional bytes slice_key = 1;
    optional SquidP resource = 2;
  }

  // Instructs the test driver to retrieve the slice set assigned to the given resource in the
  // current assignment.
  message GetSliceSetForResourceP {
    optional SquidP resource = 1;
  }

  // The client-chosen id of this downcall. The server will include this in the response to the
  // downcall.
  //
  // The client must ensure that ids are unique within the scope of each stream.
  optional int64 id = 1;

  oneof downcall {
    InitP init = 2;
    StartP start = 3;
    GetAssignmentP get_assignment = 7;
    IsAssignedKeyP is_assigned_key = 5;
    GetSliceSetForResourceP get_slice_set_for_resource = 6;
  }

  reserved 4;
}

// A response from the Rust test driver server subprocess back to the Scala test process regarding
// an interaction with a `SliceLookup`.
message SliceLookupResponseP {
  // A response to a downcall previously initiated by the client.
  message DowncallResultP {
    message InitResultP {}
    message StartResultP {}
    message GetAssignmentResultP {
      // OPTIONAL. Not populated if there is no current assignment.
      optional DiffAssignmentP assignment = 1;
    }
    message IsAssignedKeyResultP {
      // OPTIONAL. Not populated if there is no current assignment.
      optional bool is_assigned = 1;
    }
    message GetSliceSetForResourceResultP {
      repeated friend.SliceP slices = 1;
    }

    // The downcall id specified by the client when it initiated the downcall.
    optional int64 id = 1;

    oneof result {
      InitResultP init_result = 2;
      StartResultP start_result = 3;
      GetAssignmentResultP get_assignment_result = 7;
      IsAssignedKeyResultP is_assigned_key_result = 5;
      GetSliceSetForResourceResultP get_slice_set_for_resource_result = 6;
    }

    reserved 4;
  }

  oneof response {
    // Informs the client of a new assignment that the `SliceLookup` has learned about.
    DiffAssignmentP new_assignment = 3;

    // A response to a downcall previously initiated by the client.
    DowncallResultP downcall_result = 2;
  }

  reserved 1;
}

// Indicates whether the `SliceLookup` is running as part of a Clerk or a Slicelet.
enum ClientTypeP {
  CLIENT_TYPE_P_UNSPECIFIED = 0;
  CLERK = 1;
  SLICELET = 2;
}

// A request to create a Rust `Slicelet`.
//
// The fields of this proto correspond to parameters of `Slicelet::builder` and of the methods on
// `SliceletBuilder`.
message CreateSliceletRequestP {
  optional ClientRequestP.TargetP target = 1;

  // OPTIONAL
  optional string slicelet_hostname = 2;

  // OPTIONAL
  optional string slicelet_uuid = 3;

  // OPTIONAL
  optional string slicelet_kubernetes_namespace = 4;
}

// The response to a `CreateSlicelet` request.
message CreateSliceletResponseP {
  // The ID that can be passed to other RPCs to interact with the Slicelet.
  optional int64 slicelet_id = 1;
}

// A request to call `start` on a Rust `Slicelet`.
message StartSliceletRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;

  // The port to pass to the `start` method.
  optional int32 self_port = 2;
}

// The response to a `StartSlicelet` request.
message StartSliceletResponseP {
  oneof response {
    // Indicates that the Slicelet was started successfully.
    //
    // The value is always true.
    bool is_started = 1;

    // Indicates that the Slicelet has received a new assignment.
    //
    // The value is always true.
    bool assignment_updated = 2;
  }
}

// A request to drop a Rust `Slicelet`.
message StopSliceletRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;
}

// The response to a `StopSlicelet` request.
message StopSliceletResponseP {}

// A request to call `assigned_slices` on a Rust `Slicelet`.
message GetAssignedSlicesRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;
}

// The response to a `GetAssignedSlices` request.
message GetAssignedSlicesResponseP {
  repeated friend.SliceP slices = 1;
}

// A request to call `get_latest_assignment_for_test` for a Rust `Slicelet`.
message GetLatestAssignmentRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;
}

// The response to a `GetLatestAssignment` request.
message GetLatestAssignmentResponseP {
  // The latest assignment for the Slicelet.
  //
  // OPTIONAL
  optional DiffAssignmentP assignment = 1;
}

// A request to retrieve the SQUID of a Rust `Slicelet`.
message GetSliceletSquidRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;
}

// The response to a `GetSliceletSquid` request.
message GetSliceletSquidResponseP {
  optional SquidP squid = 1;
}

// A request to create a slice key handle using a Rust `Slicelet`.
message CreateSliceKeyHandleRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;

  // The slice key to create a handle for.
  optional bytes slice_key = 2;
}

// The response to a `CreateSliceKeyHandle` request.
message CreateSliceKeyHandleResponseP {
  // The ID that can be passed to other RPCs to interact with the handle.
  optional int64 handle_id = 1;
}

// A request to check whether a slice key handle is continuously assigned.
message GetSliceKeyHandleIsAssignedContinuouslyRequestP {
  // The ID for the handle that was previously returned by a `CreateSliceKeyHandle` request.
  optional int64 handle_id = 1;
}

// The response to a `GetSliceKeyHandleIsAssignedContinuously` request.
message GetSliceKeyHandleIsAssignedContinuouslyResponseP {
  optional bool is_assigned_continuously = 1;
}

// A request to close a slice key handle.
message CloseSliceKeyHandleRequestP {
  // The ID for the handle that was previously returned by a `CreateSliceKeyHandle` request.
  optional int64 handle_id = 1;
}

// The response to a `CloseSliceKeyHandle` request.
message CloseSliceKeyHandleResponseP {}

// A request to increment load by a given value for a slice key handle.
message IncrementSliceKeyHandleLoadByRequestP {
  // The ID for the handle that was previously returned by a `CreateSliceKeyHandle` request.
  optional int64 handle_id = 1;

  // The load value to increment by. Must be positive.
  optional int32 value = 2;
}

// The response to a `IncrementSliceKeyHandleLoadBy` request.
message IncrementSliceKeyHandleLoadByResponseP {}

// A request to advance the fake time by the specified duration.
message AdvanceTimeRequestP {
  // The duration to advance time by (in milliseconds).
  optional int64 duration_millis = 1;
}

// The response to an `AdvanceTime` request.
message AdvanceTimeResponseP {
  // The current timestamp since the start time of the fake time driver (in milliseconds).
  optional int64 millis_since_start = 1;
}

// The location of a SubscriberHandler.
enum HandlerLocationP {
  HANDLER_LOCATION_P_UNSPECIFIED = 0;
  HANDLER_ASSIGNER = 1;
  HANDLER_SLICELET = 2;
  HANDLER_CLERK = 3;
}

// A request to create a `SubscriberHandler`.
message CreateSubscriberHandlerRequestP {
  optional HandlerLocationP handler_location = 1;
  optional ClientRequestP.TargetP target = 2;
}

// The response to a `CreateSubscriberHandler` request.
message CreateSubscriberHandlerResponseP {
  // The ID that can be passed to other RPCs to interact with the
  // SubscriberHandler.
  optional int64 handler_id = 1;
}

// A request to set the assignment in the handler's watch cell.
message SetSubscriberHandlerAssignmentRequestP {
  // The assignment to set in the cell.
  optional DiffAssignmentP assignment = 1;
}

// The response to a `SetSubscriberHandlerAssignment` request.
message SetSubscriberHandlerAssignmentResponseP {}

// A request to call `handle_watch` on a `SubscriberHandler`.
message WatchSubscriberHandlerRequestP {
  // The ID for the SubscriberHandler.
  optional int64 handler_id = 1;

  // The client request to handle.
  optional ClientRequestP client_request = 2;
}

// The response to a `WatchSubscriberHandler` request.
message WatchSubscriberHandlerResponseP {
  // The response from handling the watch request.
  optional ClientResponseP response = 1;
}

// A request to cancel a `SubscriberHandler`.
message CancelSubscriberHandlerRequestP {
  // The ID for the SubscriberHandler.
  optional int64 handler_id = 1;
}

// The response to a `CancelSubscriberHandler` request.
message CancelSubscriberHandlerResponseP {}

// A request to get the watch server port of a Rust `Slicelet`.
message GetSliceletWatchServerPortRequestP {
  // The ID for the Slicelet that was previously returned by a `CreateSlicelet` request.
  optional int64 slicelet_id = 1;
}

// The response to a `GetSliceletWatchServerPort` request.
message GetSliceletWatchServerPortResponseP {
  // The port on which the Slicelet's watch server is listening.
  optional int32 port = 1;
}

// A request to create a Rust `Clerk`.
message CreateClerkRequestP {
  optional ClientRequestP.TargetP target = 1;

  // The Slicelet port for the Clerk to connect.
  optional int32 slicelet_port = 2;
}

// The response to a `CreateClerk` request.
message CreateClerkResponseP {
  // The ID that can be passed to other RPCs to interact with the Clerk.
  optional int64 clerk_id = 1;
}

// A request to drop a Rust `Clerk`.
message StopClerkRequestP {
  // The ID for the Clerk that was previously returned by a `CreateClerk` request.
  optional int64 clerk_id = 1;
}

// The response to a `StopClerk` request.
message StopClerkResponseP {}

// A request to call `ready` on a Rust `Clerk`.
message ClerkReadyRequestP {
  // The ID for the Clerk that was previously returned by a `CreateClerk` request.
  optional int64 clerk_id = 1;
}

// The response to a `ClerkReady` request.
message ClerkReadyResponseP {}

// A request to call `get_stub_for_key` on a Rust `Clerk`.
message ClerkGetStubForKeyRequestP {
  // The ID for the Clerk that was previously returned by a `CreateClerk` request.
  optional int64 clerk_id = 1;

  // The slice key to look up.
  optional bytes slice_key = 2;
}

// The response to a `ClerkGetStubForKey` request.
message ClerkGetStubForKeyResponseP {
  // The resource address for the key, if one is assigned.
  optional string resource_address = 1;
}

// A request to sample `get_stub_for_key` multiple times for statistical testing.
message ClerkSampleStubForKeyRequestP {
  // The ID for the Clerk that was previously returned by a `CreateClerk` request.
  optional int64 clerk_id = 1;

  // The slice key to look up.
  optional bytes slice_key = 2;

  // The number of times to sample `get_stub_for_key`.
  optional int32 sample_count = 3;
}

// The response to a `ClerkSampleStubForKey` request.
message ClerkSampleStubForKeyResponseP {
  // A single entry representing a resource and how many times it was returned.
  message ResultEntry {
    // The resource address (URI).
    optional string resource_address = 1;

    // The number of times this resource was returned.
    optional int32 count = 2;
  }

  // The aggregated results of the sampled calls.
  repeated ResultEntry results = 1;
}

// A request to create a Rust `CrossClusterClerk` that can subscribe to assignments for targets
// in remote clusters.
message CreateCrossClusterClerkRequestP {
  // The name of the Dicer target (must meet RFC 1123 label name requirements).
  optional string target_name = 1;

  // The Kubernetes cluster URI where the Slicelet is running.
  optional string target_cluster_uri = 2;

  // The Slicelet port for the Clerk to connect to.
  optional int32 slicelet_port = 3;
}

// The response to a `CreateCrossClusterClerk` request.
message CreateCrossClusterClerkResponseP {
  // The ID that can be passed to other RPCs to interact with the Clerk.
  optional int64 clerk_id = 1;
}

// A request to get the debug name of a Rust `Clerk`.
message GetClerkDebugNameRequestP {
  // The ID for the Clerk that was previously returned by a `CreateClerk` request.
  optional int64 clerk_id = 1;
}

// The response to a `GetClerkDebugName` request.
message GetClerkDebugNameResponseP {
  // The debug name of the Clerk.
  optional string debug_name = 1;
}
