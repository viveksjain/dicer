package com.databricks.dicer.external

import java.io.File
import java.net.URI
import java.time.Instant
import java.util.UUID

import scala.collection.mutable
import scala.concurrent.duration.Duration
import scala.concurrent.Future

import com.databricks.rpc.RequestHeaders

import com.databricks.caching.util.AssertMacros.ifail
import com.databricks.caching.util.PrefixLogger
import com.databricks.caching.util.TestUtils
import com.databricks.conf.Config
import com.databricks.dicer.assigner.InterposingEtcdPreferredAssignerDriver
import com.databricks.dicer.assigner.config.InternalTargetConfigMap
import com.databricks.dicer.client.{Ports, TestClientUtils, TlsFilePaths}
import com.databricks.dicer.common.SliceKeyHelper.IdentitySliceKeyFunction
import com.databricks.dicer.common.SliceletData.SliceLoad
import com.databricks.dicer.common.{
  Assignment,
  ClientRequest,
  Generation,
  InternalDicerTestEnvironment,
  ProposedSliceAssignment,
  SliceMapHelper,
  SliceletData,
  Squid,
  TestAssigner
}
import com.databricks.dicer.external.DicerTestEnvironment.TestAssignmentBuilder.BLACKHOLE_RESOURCE
import com.databricks.dicer.external.DicerTestEnvironment.{
  AssignmentHandle,
  TestAssignment,
  TestAssignmentBuilder
}
import com.databricks.dicer.friend.SliceMap
import com.databricks.threading.NamedExecutor
import com.databricks.rpc.tls.TLSOptions


/**
 * Keystore and Truststore paths for constructing a [[TLSOptions]]. The TLSOptions is used to
 * override dicerTlsOptions by setting [[databricks.dicer.library.*.keystore]].
 * This is only used for testing purposes.
 */
case class DicerTlsFilePaths(keystorePath: String, truststorePath: String)

/**
 * This is a test environment for applications to test against `Dicer`. It is strongly recommended
 * that the test code create a single [[DicerTestEnvironment]] for the entire test suite rather than
 * creating a new one for each test, but use a different [[Target]] in each test to avoid
 * interference between test cases, e.g.:
 *
 * {{{
 *   class MySuite extends DatabricksTest {
 *     private val env = DicerTestEnvironment.create()
 *
 *     // Environment should be stopped after all tests are done.
 *     override def afterAll(): Unit = env.stop()
 *
 *     test("Hello, Dicer!") {
 *       val target = Target("hello_dicer_target")
 *       val slicelet: Slicelet = createSlicelet(target, env.getConnectionConfigForNewSlicelet)
 *       ???
 *     }
 *
 *     test("Hello, Dicer again!") {
 *       val target = Target("hello_dicer_again_target")
 *       ???
 *     }
 *   }
 * }}}
 *
 * Rather than explicitly creating a [[DicerTestEnvironment]] as in the example above, you can
 * use a [[DicerTestEnvironmentMixin]] to create a [[DicerTestEnvironment]] for you. This mixin
 * exposes a high-fidelity Dicer service fake in the simulation platform
 * (<internal link>), but is used in the same way as the regular
 * [[DicerTestEnvironment]], e.g.:
 *
 * {{{
 *   class MySuite extends DatabricksTest with SimulationMixin with DicerTestEnvironmentMixin {
 *     // NOTE: The simulation platform environment does not need to be stopped.
 *
 *     test("Hello, Dicer!") {
 *       val target = Target("hello_dicer_target")
 *       val env: DicerTestEnvironment = this.dicerTestEnv
 *       val slicelet: Slicelet = createSlicelet(target, env.getConnectionConfigForNewSlicelet)
 *       ???
 *     }
 *   }
 * }}}
 *
 * At the end of each test, stop the Clerks and Slicelets, e.g.:
 *
 * {{{
 *   test("Hello, Dicer!") {
 *     val clerk: Clerk = ???
 *     val slicelet: Slicelet = ???
 *
 *     // Your test code here.
 *     ???
 *
 *     // Stop Clerks and Slicelets created for the test.
 *     clerk.forTest.stop()
 *     slicelet.forTest.stop()
 *   }
 * }}}
 *
 * In each test, the application should initialize Clerks and Slicelets. To ensure Clerks and
 * Slicelets can talk to Dicer in a test environment, applications should inject connection
 * configuration in their service configuration. The file [[DicerTestEnvironmentSuite]] has examples
 * that one can follow.
 *
 * {{{
 *  val testClerkConf = new SampleClerkServerConf(
 *       BackendProject.TestProject,
 *       // Inject connection config for Clerk to be able to talk to Dicer.
 *       Configs.empty.withFallback(env.getConnectionConfigForNewClerk)
 *   )
 *   val testSliceletConf = new SampleSliceletServerConf(
 *       BackendProject.TestProject,
 *       // Inject connection config for Slicelets to be able to talk to Dicer.
 *       Configs.empty.withFallback(env.getConnectionConfigForNewSlicelet)
 *   )
 * }}}
 *
 * This environment has two modes - regular mode and frozen mode. In the former case, the system
 * works normally where the assignment is generated by Dicer and pushed to all Clerks and Slicelets.
 * In the frozen case, the assignment is provided by the caller using [[setAndFreezeAssignment]] -
 * that particular assignment is then propagated to all Clerks and Slicelets. The former allows
 * testing as the system would run in production and the latter allows controlled placement of keys
 * or ranges for specific tests. See [[DicerTestEnvironmentSuite]] for examples.
 *
 * @param tlsFilePathsOpt An option of the path to the keystore/truststore files for TLSOptions.
 *                        When not set, default test keystore/truststore paths defined in
 *                        [[com.databricks.rpc.testing.TestTLSOptions]] are used.
 * @param injectedAssignerPortOpt An option of function that returns an integer as an injected
 *                                assigner port. When set, `getConnectionConfigForNewSlicelet` and
 *                                `getAssignerPort` will use this port for the assigner's address.
 *                                Otherwise, they will use `internalTestEnv.getAssignerPort`. This
 *                                is defined as a function to support the cases when assigner port
 *                                is still not available when DicerTestEnvironment is being created,
 *                                e.g. [[SimulationAccessMixin.simulationPortProvider]].
 */
class DicerTestEnvironment private[dicer] (
    private[dicer] val internalTestEnv: InternalDicerTestEnvironment,
    private[dicer] val tlsFilePathsOpt: Option[DicerTlsFilePaths] = None,
    injectedAssignerPortOpt: Option[() => Int] = None) {

  private val logger = PrefixLogger.create(this.getClass, "")
  private val internalTlsFilePathsOpt = tlsFilePathsOpt.map(
    tlsFilePaths => TlsFilePaths(tlsFilePaths.keystorePath, tlsFilePaths.truststorePath)
  )

  /**
   * Returns a new [[TestAssignmentBuilder]] that can be used to build assignments of keys to
   * resources used in [[setAndFreezeAssignment]].
   */
  def newAssignmentBuilder(): TestAssignmentBuilder = new TestAssignmentBuilder()

  /**
   * Sets the assignment for `target` to be the one specified by `testAssignment`. Any
   * changes to the Slicelets, e.g., adding more, will have no effect on the assignment unless the
   * caller calls [[setAndFreezeAssignment]] again or calls [[unfreezeAssignment]] which
   * resumes assignment generation by Dicer. Returns a handle corresponding to this assignment.
   * Later calls to [[setAndFreezeAssignment]] results in handles which are higher than earlier
   * ones. The caller cannot compare handles but can use them with the [[hasReceivedAtLeast]] call
   * to determine if (at least) this assignment has been received by the Clerk/Slicelet.
   *
   * NOTE: The caller must not assume that each Clerk or Slicelet has received the assignment after
   * this call returns. They will receive the assignment eventually. The caller can use
   * [[hasReceivedAtLeast]] to determine if a particular Clerk or Slicelet has received the
   * assignment.
   *
   * See [[DicerTestEnvironmentSuite]] for examples on how to use this in a test.
   */
  def setAndFreezeAssignment(target: Target, testAssignment: TestAssignment): AssignmentHandle = {
    val assignment: Assignment = TestUtils.awaitResult(
      internalTestEnv.setAndFreezeAssignment(
        target,
        testAssignment.proposedAssignment
      ),
      Duration.Inf
    )
    logger.info(s"Received setAndFreezeAssignment for $target")
    new AssignmentHandle(assignment.generation)
  }

  /**
   * Returns the total attributed load reported in the latest watch request,
   * or 0 if no attributed load has been reported.
   */
  def getTotalAttributedLoad(target: Target): Double = {
    val requestOpt: Option[ClientRequest] =
      internalTestEnv.testAssigner.getLatestSliceletWatchRequest(target).map {
        case (_: RequestHeaders, req: ClientRequest) => req
      }
    if (requestOpt.isEmpty) { // No watch request received yet.
      0
    } else {
      requestOpt.get.subscriberData match {
        case sliceletData: SliceletData =>
          sliceletData.attributedLoads.map((sliceLoad: SliceLoad) => sliceLoad.primaryRateLoad).sum
        case _ => // No slicelet data in the request.
          ifail("Found non-slicelet request in the latest sliecelet watch request.")
      }
    }
  }

  /**
   * Returns whether the Clerk has observed an assignment that is at least as recent as the one
   * represented by `handle`.
   */
  def hasReceivedAtLeast(handle: AssignmentHandle, clerk: Clerk[_]): Boolean = {
    clerk.impl.forTest.getLatestAssignmentOpt match {
      case Some(latestAssignment: Assignment) =>
        latestAssignment.generation >= handle.assignmentGeneration
      case None => false
    }
  }

  /**
   * Returns whether the Slicelet and its (optional) SliceletListener have observed an assignment
   * that is at least as recent as the one represented by `handle`.
   */
  def hasReceivedAtLeast(handle: AssignmentHandle, slicelet: Slicelet): Boolean = {
    val lowerBound: Generation =
      TestUtils.awaitResult(slicelet.impl.forTest.getListenerGenerationLowerBound, Duration.Inf)
    lowerBound >= handle.assignmentGeneration
  }

  /**
   * Allows Dicer to generate assignments, if was not generating them already. If already
   * unfrozen, this is a no-op. After unfreezing (from a freeze), Dicer may or may not propagate a
   * new assignment to the Clerks and Slicelets.
   *
   * Returns a future that completes once the assignment has been unfrozen (or determined to already
   * be unfrozen).
   */
  def unfreezeAssignment(target: Target): Future[Unit] = {
    logger.info(s"Received unfreezeAssignment for $target")
    internalTestEnv
      .unfreezeAssignment(target)
      .map[Unit] { _: Option[Assignment] =>
      }(NamedExecutor.globalImplicit)
  }

  /** Stops the environment. No function on this environment must be called after this call. */
  def stop(): Unit =
    internalTestEnv.testAssigner.stop(InterposingEtcdPreferredAssignerDriver.ShutdownOption.ABRUPT)

  /**
   * REQUIRES: `slicelet` has been started.
   *
   * Connection configuration for Clerks in the test environment. This should be injected
   * into services that instantiate a new Clerk. The same connection config must not be used for
   * different Clerks.
   */
  def getConnectionConfigForNewClerk(slicelet: Slicelet): Config = {
    TestClientUtils.createClerkConfig(
      slicelet.impl.forTest.sliceletPort,
      clientTlsFilePathsOpt = internalTlsFilePathsOpt
    )
  }

  /**
   * Connection configuration for Slicelets in the test environment. This should be injected
   * into services that instantiate a Slicelet. For every new Slicelet, the caller must call this
   * method. Reusing a conf across Slicelets result in undefined behavior, e.g., crashes.
   * If a server instantiates a Clerk and a Slicelet, it should call this method.
   */
  def getConnectionConfigForNewSlicelet: Config = {
    TestClientUtils.createSliceletConfig(
      getAssignerPort,
      sliceletHost = internalTestEnv.sliceletHostNameOpt.getOrElse("localhost"),
      clientTlsFilePathsOpt = internalTlsFilePathsOpt,
      serverTlsFilePathsOpt = internalTlsFilePathsOpt,
      watchFromDataPlane = false
    )
  }


  /** Returns the port for the assigner chosen by the environment. For internal use only. */
  private[dicer] def getAssignerPort: Int = {
    injectedAssignerPortOpt match {
      case Some(injectedAssignerPort) => injectedAssignerPort()
      case None => internalTestEnv.getAssignerPort
    }
  }
}

object DicerTestEnvironment {

  /** For test environment, a target configuration must be created for dev. */
  private val TARGET_CONFIG_MAP = InternalTargetConfigMap.create(
    configScopeOpt = None,
    new File("dicer/external/config/dev/"),
    new File("dicer/assigner/advanced_config/dev/")
  )

  /**
   * Returns an environment that can be used for testing with Dicer.
   * @param tlsFilePathsOpt the keystore/truststore paths used by Clerks and Slicelets to connect
   *                        to Slicelets and the Assigner respectively.
   * @param sliceletHostNameOpt the host name for slicelets.
   */
  def create(
      tlsFilePathsOpt: Option[DicerTlsFilePaths] = None,
      sliceletHostNameOpt: Option[String] = None): DicerTestEnvironment = {
    val tlsOptionsOpt = (tlsFilePathsOpt) match {
      case (Some(DicerTlsFilePaths(keystorePath, truststorePath))) =>
        Some(
          TLSOptions.builder
            .addKeyManager(new File(keystorePath), new File(keystorePath))
            .addTrustManager(new File(truststorePath))
            .build()
        )
      case _ => None
    }
    val internalTestEnv =
      InternalDicerTestEnvironment.create(
        config = TestAssigner.Config.create(tlsOptionsOpt = tlsOptionsOpt),
        targetConfigMap = TARGET_CONFIG_MAP,
        tlsFilePathsOpt = tlsFilePathsOpt.map(
          tlsFilePaths => TlsFilePaths(tlsFilePaths.keystorePath, tlsFilePaths.truststorePath)
        ),
        sliceletHostNameOpt = sliceletHostNameOpt
      )
    new DicerTestEnvironment(
      internalTestEnv,
      tlsFilePathsOpt = tlsFilePathsOpt
    )
  }

  /**
   * A handle that can be used by the application to determine if the frozen assignment has been
   * received by the relevant Clerk or Slicelet (see [[DicerTestEnvironment.hasReceivedAtLeast]].
   */
  class AssignmentHandle private[external] (
      private[external] val assignmentGeneration: Generation) {
    override def toString: String = assignmentGeneration.toString
  }

  /**
   * A builder for creating assignments. Overlapping assignments of keys to resources are not
   * permitted (see specs in [[build]].
   */
  class TestAssignmentBuilder private[external] () {

    /** The slice assignments that are being constructed. */
    private val sliceAssignments = mutable.ArrayBuffer[ProposedSliceAssignment]()

    /** Assigns `key` to the given `slicelet`. */
    def add(key: SliceKey, slicelet: Slicelet): this.type = add(key, Iterable(slicelet))

    /** Assigns `slice` to the given `slicelet`. */
    def add(slice: Slice, slicelet: Slicelet): this.type = {
      add(slice, Iterable(slicelet))
    }

    /** Assigns `key` to the given `slicelets`. */
    @throws[IllegalArgumentException]("If the assigned `slicelets` is empty.")
    def add(key: SliceKey, slicelets: Iterable[Slicelet]): this.type =
      add(createSingleKeySlice(key), slicelets)

    /** Assigns `slice` to the given `slicelets`. */
    @throws[IllegalArgumentException]("If the assigned `slicelets` is empty.")
    def add(slice: Slice, slicelets: Iterable[Slicelet]): this.type = {
      sliceAssignments.append(
        // This call throws if `slicelets` is empty.
        ProposedSliceAssignment(
          slice,
          resources = slicelets.map((_: Slicelet).impl.squid).toSet,
          primaryRateLoadOpt = None
        )
      )
      this
    }

    /**
     * REQUIRES: no [[add]]ed assignments can reference the same key or overlapping keys.
     *
     * Builds a [[TestAssignment]] based on the mappings that have been added. Any keys that have
     * not been added will be assigned to http://192.0.2.0:8080, which is a black hole
     * (documentation only) address.
     */
    def build(): TestAssignment = {
      // Sort the slice assignments so that we can easily identify overlaps and fill gaps in the
      // assignment.
      val sorted: mutable.Seq[ProposedSliceAssignment] = sliceAssignments.sortBy {
        sliceAssignment: ProposedSliceAssignment =>
          sliceAssignment.slice
      }
      // Create slice assignments in a sorted array by iterating through the sorted slice
      // assignments. All unassigned slices are mapped to BLACKHOLE_RESOURCE_ADDRESS.
      //
      // For example, given slice assignments:
      //    [A,B)=>res0
      //    [C,D)=>res1
      //    [E,E\0)=>res0 # Singleton slice including just E
      // The filled out assignment is:
      //    ["",A)=>BLACKHOLE_RESOURCE
      //    [A,B)=>res0
      //    [B,C)=>BLACKHOLE_RESOURCE
      //    [C,D)=>res1
      //    [D,E)=>BLACKHOLE_RESOURCE
      //    [E,E\0)=>res0
      //    [E\0,∞)=>BLACKHOLE_RESOURCE
      val completeSliceAssignments = Vector.newBuilder[ProposedSliceAssignment]
      var previousHigh: HighSliceKey = SliceKey.MIN
      for (sliceAssignment: ProposedSliceAssignment <- sorted) {
        val low: SliceKey = sliceAssignment.slice.lowInclusive
        previousHigh match {
          case previousHigh: SliceKey if previousHigh < low =>
            // Fill in gap between the previous Slice and the current Slice.
            completeSliceAssignments += ProposedSliceAssignment(
              Slice(previousHigh, low),
              resources = Set(BLACKHOLE_RESOURCE),
              primaryRateLoadOpt = None
            )
          case _ =>
            if (previousHigh > low) {
              throw new IllegalArgumentException(
                s"Slices must not overlap: $previousHigh > $low"
              )
            }
        }
        completeSliceAssignments += sliceAssignment
        previousHigh = sliceAssignment.slice.highExclusive
      }
      // Last slice high value must be ∞.
      if (previousHigh.isFinite) {
        val previousLow: SliceKey = previousHigh.asFinite
        completeSliceAssignments += ProposedSliceAssignment(
          Slice.atLeast(previousLow),
          resources = Set(BLACKHOLE_RESOURCE),
          primaryRateLoadOpt = None
        )
      }
      val proposedAssignment =
        SliceMapHelper.ofProposedSliceAssignments(completeSliceAssignments.result())
      new TestAssignment(proposedAssignment)
    }
  }
  object TestAssignmentBuilder {

    /** The address of the resource to which all unassigned keys are routed. */
    private[dicer] val BLACKHOLE_RESOURCE: Squid = Squid(
      ResourceAddress(URI.create("http://192.0.2.0:8080")),
      creationTimeMillis = Instant.EPOCH.toEpochMilli,
      new UUID(0, 0)
    )
  }

  /**
   * The class that provides the assignment of keys to pods for freezing assignments. These
   * assignments are created using the [[DicerTestEnvironment.TestAssignmentBuilder]].
   */
  class TestAssignment private[external] (
      private[external] val proposedAssignment: SliceMap[ProposedSliceAssignment])

  /** Returns a Slice containing only the given `key`. */
  private def createSingleKeySlice(key: SliceKey): Slice = {
    val successorBytes = new Array[Byte](key.bytes.size + 1) // key bytes + trailing 0
    key.bytes.toByteArray.copyToArray(successorBytes)
    val successorKey = SliceKey(successorBytes, IdentitySliceKeyFunction)
    Slice(key, successorKey)
  }
}
